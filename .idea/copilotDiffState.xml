<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/(auth)/signup/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/(auth)/signup/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 회원가입 페이지&#10; * &#10; * TanStack Query의 useUpdateProfileInSignup 뮤테이션을 사용하여&#10; * 회원가입 프로필 업데이트를 효율적으로 처리합니다.&#10; */&#10;&#10;import SignupForm from &quot;@/components/features/auth/SignupForm&quot;;&#10;import { Position } from &quot;@/enums/position&quot;;&#10;import { useAuth, useUpdateProfileInSignup } from &quot;@/hooks/queries/useUserQueries&quot;;&#10;import {&#10;  SignupFormValues,&#10;  signupSchema,&#10;} from &quot;@/lib/schemas/signupSchema&quot;;&#10;import type { UserProfileRequest } from &quot;@/generated/api&quot;;&#10;import { zodResolver } from &quot;@hookform/resolvers/zod&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { useForm } from &quot;react-hook-form&quot;;&#10;&#10;export default function SignupPage() {&#10;  const router = useRouter();&#10;  const { refetchAuthStatus } = useAuth();&#10;&#10;  /**&#10;   * TanStack Query 뮤테이션을 사용한 회원가입 프로필 업데이트&#10;   * &#10;   * 이 훅의 장점:&#10;   * - 자동 캐시 관리: 사용자 프로필 캐시 자동 업데이트&#10;   * - 로딩 상태: isPending을 통한 폼 비활성화&#10;   * - 에러 처리: 자동 에러 핸들링 및 롤백&#10;   * - 성공 후 처리: onSuccess 콜백을 통한 리디렉션&#10;   */&#10;  const updateProfileMutation = useUpdateProfileInSignup();&#10;&#10;  const form = useForm&lt;SignupFormValues&gt;({&#10;    resolver: zodResolver(signupSchema),&#10;    defaultValues: {&#10;      email: &quot;&quot;,&#10;      studentNumber: &quot;&quot;,&#10;      gamjaBatch: undefined,&#10;      position: undefined,&#10;      privacyAgree1: false,&#10;      privacyAgree2: false,&#10;    },&#10;    mode: &quot;onChange&quot;,&#10;  });&#10;&#10;  const { isValid } = form.formState;&#10;&#10;  const onSubmit = async (data: SignupFormValues) =&gt; {&#10;    const positionKey = (&#10;      Object.keys(Position) as Array&lt;keyof typeof Position&gt;&#10;    ).find((key) =&gt; Position[key] === data.position);&#10;&#10;    const payload: UserProfileRequest = {&#10;      email: data.email,&#10;      studentNumber: data.studentNumber,&#10;      gamjaBatch: data.gamjaBatch,&#10;      position: positionKey as UserProfileRequest['position'],&#10;    };&#10;&#10;    // TanStack Query 뮤테이션 실행&#10;    try {&#10;      await updateProfileMutation.mutateAsync(payload);&#10;&#10;      // 인증 상태 업데이트 (기존 로직 유지)&#10;      await refetchAuthStatus();&#10;&#10;      // 성공 시 메인 페이지로 이동&#10;      router.push(&quot;/&quot;);&#10;&#10;    } catch (error) {&#10;      // 에러는 TanStack Query의 onError에서 이미 처리됨&#10;      // 추가 사용자 피드백이 필요하면 여기에 추가&#10;      console.error(&quot;Signup failed:&quot;, error);&#10;      alert(&quot;회원 정보 업데이트에 실패했습니다. 다시 시도해주세요.&quot;);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;main className=&quot;flex flex-col items-center justify-center bg-white min-h-screen&quot;&gt;&#10;      &lt;header className=&quot;mb-8&quot;&gt;&#10;        &lt;Link href=&quot;/&quot; aria-label=&quot;메인페이지로 이동&quot;&gt;&#10;          &lt;Image&#10;            src=&quot;/logo2.svg&quot;&#10;            alt=&quot;Gamza Tech Blog 로고&quot;&#10;            width={220}&#10;            height={180}&#10;            priority&#10;          /&gt;&#10;        &lt;/Link&gt;&#10;      &lt;/header&gt;&#10;&#10;      &lt;section aria-label=&quot;회원가입&quot;&gt;&#10;        &lt;h1 className=&quot;sr-only&quot;&gt;회원가입&lt;/h1&gt;&#10;        &lt;SignupForm form={form} onSubmit={onSubmit} isValid={isValid} /&gt;&#10;      &lt;/section&gt;&#10;    &lt;/main&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 회원가입 페이지&#10; * &#10; * TanStack Query의 useUpdateProfileInSignup 뮤테이션을 사용하여&#10; * 회원가입 프로필 업데이트를 효율적으로 처리합니다.&#10; */&#10;&#10;import SignupForm from &quot;@/components/features/auth/SignupForm&quot;;&#10;import { Position } from &quot;@/enums/position&quot;;&#10;import { useAuth, useUpdateProfileInSignup } from &quot;@/hooks/queries/useUserQueries&quot;;&#10;import {&#10;  SignupFormValues,&#10;  signupSchema,&#10;} from &quot;@/lib/schemas/signupSchema&quot;;&#10;import type { UserProfileRequest } from &quot;@/generated/api&quot;;&#10;import { zodResolver } from &quot;@hookform/resolvers/zod&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { useForm } from &quot;react-hook-form&quot;;&#10;&#10;export default function SignupPage() {&#10;  const router = useRouter();&#10;  const { refetchAuthStatus } = useAuth();&#10;&#10;  /**&#10;   * TanStack Query 뮤테이션을 사용한 회원가입 프로필 업데이트&#10;   * &#10;   * 이 훅의 장점:&#10;   * - 자동 캐시 관리: 사용자 프로필 캐시 자동 업데이트&#10;   * - 로딩 상태: isPending을 통한 폼 비활성화&#10;   * - 에러 처리: 자동 에러 핸들링 및 롤백&#10;   * - 성공 후 처리: onSuccess 콜백을 통한 리디렉션&#10;   */&#10;  const updateProfileMutation = useUpdateProfileInSignup();&#10;&#10;  const form = useForm&lt;SignupFormValues&gt;({&#10;    resolver: zodResolver(signupSchema),&#10;    defaultValues: {&#10;      email: &quot;&quot;,&#10;      studentNumber: &quot;&quot;,&#10;      gamjaBatch: undefined,&#10;      position: undefined,&#10;      privacyAgree1: false,&#10;      privacyAgree2: false,&#10;    },&#10;    mode: &quot;onChange&quot;,&#10;  });&#10;&#10;  const { isValid } = form.formState;&#10;&#10;  const onSubmit = async (data: SignupFormValues) =&gt; {&#10;    const positionKey = (&#10;      Object.keys(Position) as Array&lt;keyof typeof Position&gt;&#10;    ).find((key) =&gt; Position[key] === data.position);&#10;&#10;    const payload: UserProfileRequest = {&#10;      email: data.email,&#10;      studentNumber: data.studentNumber,&#10;      gamjaBatch: data.gamjaBatch,&#10;      position: positionKey as UserProfileRequest['position'],&#10;    };&#10;&#10;    // TanStack Query 뮤테이션 실행&#10;    try {&#10;      await updateProfileMutation.mutateAsync(payload);&#10;&#10;      // 인증 상태 업데이트 (기존 로직 유지)&#10;      await refetchAuthStatus();&#10;&#10;      // 성공 시 메인 페이지로 이동&#10;      router.push(&quot;/&quot;);&#10;&#10;    } catch (error) {&#10;      // 에러는 TanStack Query의 onError에서 이미 처리됨&#10;      // 추가 사용자 피드백이 필요하면 여기에 추가&#10;      console.error(&quot;Signup failed:&quot;, error);&#10;      alert(&quot;회원 정보 업데이트에 실패했습니다. 다시 시도해주세요.&quot;);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;main className=&quot;flex flex-col items-center justify-center bg-white min-h-screen&quot;&gt;&#10;      &lt;header className=&quot;mb-8&quot;&gt;&#10;        &lt;Link href=&quot;/&quot; aria-label=&quot;메인페이지로 이동&quot;&gt;&#10;          &lt;Image&#10;            src=&quot;/logo2.svg&quot;&#10;            alt=&quot;Gamza Tech Blog 로고&quot;&#10;            width={220}&#10;            height={180}&#10;            priority&#10;          /&gt;&#10;        &lt;/Link&gt;&#10;      &lt;/header&gt;&#10;&#10;      &lt;section aria-label=&quot;회원가입&quot;&gt;&#10;        &lt;h1 className=&quot;sr-only&quot;&gt;회원가입&lt;/h1&gt;&#10;        &lt;SignupForm form={form} onSubmitAction={onSubmit} isValid={isValid} /&gt;&#10;      &lt;/section&gt;&#10;    &lt;/main&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/(content)/posts/[id]/edit/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/(content)/posts/[id]/edit/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 게시글 수정 페이지&#10; * &#10; * 공통 PostForm 컴포넌트를 사용하여 게시글 수정 기능을 구현합니다.&#10; */&#10;&#10;import PostForm, { type PostFormData } from &quot;@/components/features/posts/PostForm&quot;;&#10;import { usePost, useUpdatePost } from &quot;@/hooks/queries/usePostQueries&quot;;&#10;import { useAuth } from &quot;@/hooks/queries/useUserQueries&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { use } from &quot;react&quot;;&#10;&#10;interface EditPostPageProps {&#10;  params: Promise&lt;{&#10;    id: string;&#10;  }&gt;;&#10;}&#10;&#10;export default function EditPostPage({ params }: EditPostPageProps) {&#10;  const router = useRouter();&#10;&#10;  // Next.js 15+ params는 Promise이므로 React.use()로 unwrap&#10;  const resolvedParams = use(params);&#10;  const postId = parseInt(resolvedParams.id);&#10;&#10;  // 현재 사용자 정보 조회&#10;  const { userProfile, isLoggedIn, isLoading: isLoadingAuth } = useAuth();&#10;&#10;  // 기존 게시글 데이터 조회&#10;  const { data: post, isLoading: isLoadingPost, error } = usePost(postId);&#10;&#10;  const updatePostMutation = useUpdatePost();&#10;&#10;  const handleSubmit = async (data: PostFormData) =&gt; {&#10;    await updatePostMutation.mutateAsync({&#10;      postId,&#10;      data: {&#10;        title: data.title,&#10;        content: data.content,&#10;        tags: data.tags,&#10;        commitMessage: data.commitMessage,&#10;      }&#10;    });&#10;&#10;    // 성공 시 게시글 상세 페이지로 이동&#10;    router.push(`/posts/${postId}`);&#10;  };&#10;&#10;  // 로딩 중 UI (인증 정보 또는 게시글 로딩 중)&#10;  if (isLoadingAuth || isLoadingPost) {&#10;    return (&#10;      &lt;div className=&quot;mt-32 flex justify-center items-center min-h-[400px]&quot;&gt;&#10;        &lt;div className=&quot;text-lg text-gray-600&quot;&gt;&#10;          {isLoadingAuth ? &quot;사용자 정보를 확인하는 중...&quot; : &quot;게시글을 불러오는 중...&quot;}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 로그인하지 않은 경우&#10;  if (!isLoggedIn || !userProfile) {&#10;    return (&#10;      &lt;div className=&quot;mt-32 flex flex-col justify-center items-center min-h-[400px] gap-4&quot;&gt;&#10;        &lt;div className=&quot;text-lg text-red-600&quot;&gt;로그인이 필요합니다.&lt;/div&gt;&#10;        &lt;button&#10;          onClick={() =&gt; router.push('/login')}&#10;          className=&quot;px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;        &gt;&#10;          로그인하기&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 게시글 로딩 에러 또는 존재하지 않는 경우&#10;  if (error || !post) {&#10;    return (&#10;      &lt;div className=&quot;mt-32 flex flex-col justify-center items-center min-h-[400px] gap-4&quot;&gt;&#10;        &lt;div className=&quot;text-lg text-red-600&quot;&gt;게시글을 불러올 수 없습니다.&lt;/div&gt;&#10;        &lt;button&#10;          onClick={() =&gt; router.back()}&#10;          className=&quot;px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600&quot;&#10;        &gt;&#10;          뒤로 가기&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 작성자 권한 확인 (GitHub ID 또는 닉네임으로 비교)&#10;  const isAuthor = userProfile.githubId === post.writer ||&#10;    userProfile.nickname === post.writer ||&#10;    userProfile.name === post.writer;&#10;&#10;  if (!isAuthor) {&#10;    return (&#10;      &lt;div className=&quot;mt-32 flex flex-col justify-center items-center min-h-[400px] gap-4&quot;&gt;&#10;        &lt;div className=&quot;text-lg text-red-600&quot;&gt;이 게시글을 수정할 권한이 없습니다.&lt;/div&gt;&#10;        &lt;div className=&quot;text-sm text-gray-600&quot;&gt;본인이 작성한 게시글만 수정할 수 있습니다.&lt;/div&gt;&#10;        &lt;div className=&quot;flex gap-2&quot;&gt;&#10;          &lt;button&#10;            onClick={() =&gt; router.push(`/posts/${postId}`)}&#10;            className=&quot;px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;          &gt;&#10;            게시글 보기&#10;          &lt;/button&gt;&#10;          &lt;button&#10;            onClick={() =&gt; router.back()}&#10;            className=&quot;px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600&quot;&#10;          &gt;&#10;            뒤로 가기&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;PostForm&#10;      mode=&quot;edit&quot;&#10;      initialData={{&#10;        title: post.title || '',&#10;        content: post.content || '',&#10;        tags: post.tags || []&#10;      }}&#10;      onSubmit={handleSubmit}&#10;      isLoading={updatePostMutation.isPending}&#10;    /&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 게시글 수정 페이지&#10; * &#10; * 공통 PostForm 컴포넌트를 사용하여 게시글 수정 기능을 구현합니다.&#10; */&#10;&#10;import PostForm, { type PostFormData } from &quot;@/components/features/posts/PostForm&quot;;&#10;import { usePost, useUpdatePost } from &quot;@/hooks/queries/usePostQueries&quot;;&#10;import { useAuth } from &quot;@/hooks/queries/useUserQueries&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { use } from &quot;react&quot;;&#10;&#10;interface EditPostPageProps {&#10;  params: Promise&lt;{&#10;    id: string;&#10;  }&gt;;&#10;}&#10;&#10;export default function EditPostPage({ params }: EditPostPageProps) {&#10;  const router = useRouter();&#10;&#10;  // Next.js 15+ params는 Promise이므로 React.use()로 unwrap&#10;  const resolvedParams = use(params);&#10;  const postId = parseInt(resolvedParams.id);&#10;&#10;  // 현재 사용자 정보 조회&#10;  const { userProfile, isLoggedIn, isLoading: isLoadingAuth } = useAuth();&#10;&#10;  // 기존 게시글 데이터 조회&#10;  const { data: post, isLoading: isLoadingPost, error } = usePost(postId);&#10;&#10;  const updatePostMutation = useUpdatePost();&#10;&#10;  const handleSubmit = async (data: PostFormData) =&gt; {&#10;    await updatePostMutation.mutateAsync({&#10;      postId,&#10;      data: {&#10;        title: data.title,&#10;        content: data.content,&#10;        tags: data.tags,&#10;        commitMessage: data.commitMessage,&#10;      }&#10;    });&#10;&#10;    // 성공 시 게시글 상세 페이지로 이동&#10;    router.push(`/posts/${postId}`);&#10;  };&#10;&#10;  // 로딩 중 UI (인증 정보 또는 게시글 로딩 중)&#10;  if (isLoadingAuth || isLoadingPost) {&#10;    return (&#10;      &lt;div className=&quot;mt-32 flex justify-center items-center min-h-[400px]&quot;&gt;&#10;        &lt;div className=&quot;text-lg text-gray-600&quot;&gt;&#10;          {isLoadingAuth ? &quot;사용자 정보를 확인하는 중...&quot; : &quot;게시글을 불러오는 중...&quot;}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 로그인하지 않은 경우&#10;  if (!isLoggedIn || !userProfile) {&#10;    return (&#10;      &lt;div className=&quot;mt-32 flex flex-col justify-center items-center min-h-[400px] gap-4&quot;&gt;&#10;        &lt;div className=&quot;text-lg text-red-600&quot;&gt;로그인이 필요합니다.&lt;/div&gt;&#10;        &lt;button&#10;          onClick={() =&gt; router.push('/login')}&#10;          className=&quot;px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;        &gt;&#10;          로그인하기&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 게시글 로딩 에러 또는 존재하지 않는 경우&#10;  if (error || !post) {&#10;    return (&#10;      &lt;div className=&quot;mt-32 flex flex-col justify-center items-center min-h-[400px] gap-4&quot;&gt;&#10;        &lt;div className=&quot;text-lg text-red-600&quot;&gt;게시글을 불러올 수 없습니다.&lt;/div&gt;&#10;        &lt;button&#10;          onClick={() =&gt; router.back()}&#10;          className=&quot;px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600&quot;&#10;        &gt;&#10;          뒤로 가기&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 작성자 권한 확인 (GitHub ID 또는 닉네임으로 비교)&#10;  const isAuthor = userProfile.githubId === post.writer ||&#10;    userProfile.nickname === post.writer ||&#10;    userProfile.name === post.writer;&#10;&#10;  if (!isAuthor) {&#10;    return (&#10;      &lt;div className=&quot;mt-32 flex flex-col justify-center items-center min-h-[400px] gap-4&quot;&gt;&#10;        &lt;div className=&quot;text-lg text-red-600&quot;&gt;이 게시글을 수정할 권한이 없습니다.&lt;/div&gt;&#10;        &lt;div className=&quot;text-sm text-gray-600&quot;&gt;본인이 작성한 게시글만 수정할 수 있습니다.&lt;/div&gt;&#10;        &lt;div className=&quot;flex gap-2&quot;&gt;&#10;          &lt;button&#10;            onClick={() =&gt; router.push(`/posts/${postId}`)}&#10;            className=&quot;px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;          &gt;&#10;            게시글 보기&#10;          &lt;/button&gt;&#10;          &lt;button&#10;            onClick={() =&gt; router.back()}&#10;            className=&quot;px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600&quot;&#10;          &gt;&#10;            뒤로 가기&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;PostForm&#10;      mode=&quot;edit&quot;&#10;      initialData={{&#10;        title: post.title || '',&#10;        content: post.content || '',&#10;        tags: post.tags || []&#10;      }}&#10;      onSubmitAction={handleSubmit}&#10;      isLoading={updatePostMutation.isPending}&#10;    /&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/(content)/posts/new/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/(content)/posts/new/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 게시글 작성 페이지&#10; * &#10; * 공통 PostForm 컴포넌트를 사용하여 게시글 작성 기능을 구현합니다.&#10; */&#10;&#10;import PostForm, { type PostFormData } from &quot;@/components/features/posts/PostForm&quot;;&#10;import { useCreatePost } from &quot;@/hooks/queries/usePostQueries&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;&#10;export default function CreatePostPage() {&#10;  const router = useRouter();&#10;  const createPostMutation = useCreatePost();&#10;&#10;  const handleSubmit = async (data: PostFormData) =&gt; {&#10;    const result = await createPostMutation.mutateAsync({&#10;      title: data.title,&#10;      content: data.content,&#10;      tags: data.tags,&#10;      commitMessage: data.commitMessage,&#10;    });&#10;&#10;    // 성공 시 게시글 상세 페이지로 이동&#10;    router.push(`/posts/${result.postId}`);&#10;  };&#10;&#10;  return (&#10;    &lt;PostForm&#10;      mode=&quot;create&quot;&#10;      onSubmit={handleSubmit}&#10;      isLoading={createPostMutation.isPending}&#10;    /&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;/**&#13;&#10; * 게시글 작성 페이지&#13;&#10; * &#13;&#10; * 공통 PostForm 컴포넌트를 사용하여 게시글 작성 기능을 구현합니다.&#13;&#10; */&#13;&#10;&#13;&#10;import PostForm, { type PostFormData } from &quot;@/components/features/posts/PostForm&quot;;&#13;&#10;import { useCreatePost } from &quot;@/hooks/queries/usePostQueries&quot;;&#13;&#10;import { useRouter } from &quot;next/navigation&quot;;&#13;&#10;&#13;&#10;export default function CreatePostPage() {&#13;&#10;  const router = useRouter();&#13;&#10;  const createPostMutation = useCreatePost();&#13;&#10;&#13;&#10;  const handleSubmit = async (data: PostFormData) =&gt; {&#13;&#10;    const result = await createPostMutation.mutateAsync({&#13;&#10;      title: data.title,&#13;&#10;      content: data.content,&#13;&#10;      tags: data.tags,&#13;&#10;      commitMessage: data.commitMessage,&#13;&#10;    });&#13;&#10;&#13;&#10;    // 성공 시 게시글 상세 페이지로 이동&#13;&#10;    router.push(`/posts/${result.postId}`);&#13;&#10;  };&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;PostForm&#13;&#10;      mode=&quot;create&quot;&#13;&#10;      onSubmitAction={handleSubmit}&#13;&#10;      isLoading={createPostMutation.isPending}&#13;&#10;    /&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/features/auth/SignupForm.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/features/auth/SignupForm.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import { Checkbox } from &quot;@/components/ui/checkbox&quot;;&#10;import {&#10;  Form,&#10;  FormControl,&#10;  FormField,&#10;  FormItem,&#10;  FormLabel,&#10;  FormMessage,&#10;} from &quot;@/components/ui/form&quot;;&#10;import { Input } from &quot;@/components/ui/input&quot;;&#10;import {&#10;  Select,&#10;  SelectContent,&#10;  SelectItem,&#10;  SelectTrigger,&#10;  SelectValue,&#10;} from &quot;@/components/ui/select&quot;;&#10;import signupFields from &quot;@/constants/signupFields&quot;;&#10;import { SignupFormValues } from &quot;@/lib/schemas/signupSchema&quot;;&#10;import { UseFormReturn } from &quot;react-hook-form&quot;;&#10;&#10;const inputStyle =&#10;  &quot;flex items-center rounded-full px-6 h-12 border border-[#F2F4F6] outline-none text-[#222] placeholder:text-[#D9D9D9] text-base bg-transparent w-full focus:ring-2 focus:ring-[#20242B]/20 transition&quot;;&#10;&#10;interface SignupFormProps {&#10;  form: UseFormReturn&lt;SignupFormValues&gt;;&#10;  onSubmit: (data: SignupFormValues) =&gt; void;&#10;  isValid: boolean;&#10;}&#10;&#10;export default function SignupForm({ form, onSubmit, isValid }: SignupFormProps) {&#10;  const { handleSubmit, control } = form;&#10;&#10;  return (&#10;    &lt;Form {...form}&gt;&#10;      &lt;form&#10;        className=&quot;w-[380px] max-w-md flex flex-col&quot;&#10;        onSubmit={handleSubmit(onSubmit)}&#10;        noValidate&#10;        aria-label=&quot;회원가입 양식&quot;&#10;      &gt;&#10;        &lt;fieldset className=&quot;flex flex-col gap-6 border-b border-[#F2F4F6] pb-10&quot;&gt;&#10;          &lt;legend className=&quot;sr-only&quot;&gt;회원 정보 입력&lt;/legend&gt;&#10;&#10;          {signupFields.map((fieldInfo) =&gt; (&#10;            &lt;FormField&#10;              key={fieldInfo.id}&#10;              control={control}&#10;              name={fieldInfo.id as keyof SignupFormValues}&#10;              render={({ field }) =&gt; (&#10;                &lt;FormItem className=&quot;flex items-center&quot;&gt;&#10;                  &lt;FormLabel className=&quot;text-[#B5BBC7] text-base w-25&quot;&gt;&#10;                    {fieldInfo.label}&#10;                  &lt;/FormLabel&gt;&#10;                  &lt;div className=&quot;w-full&quot;&gt;&#10;                    &lt;FormControl&gt;&#10;                      {fieldInfo.type === &quot;option&quot; ? (&#10;                        &lt;Select&#10;                          onValueChange={field.onChange}&#10;                          value={field.value as string}&#10;                          name={field.name}&#10;                        &gt;&#10;                          &lt;SelectTrigger className={inputStyle}&gt;&#10;                            &lt;SelectValue placeholder={fieldInfo.placeholder} /&gt;&#10;                          &lt;/SelectTrigger&gt;&#10;                          &lt;SelectContent&gt;&#10;                            {fieldInfo.options?.map((option: string) =&gt; (&#10;                              &lt;SelectItem key={option} value={option}&gt;&#10;                                {option}&#10;                              &lt;/SelectItem&gt;&#10;                            ))}&#10;                          &lt;/SelectContent&gt;&#10;                        &lt;/Select&gt;&#10;                      ) : (&#10;                        &lt;Input&#10;                          {...field}&#10;                          name={field.name}&#10;                          value={String(field.value ?? &quot;&quot;)}&#10;                          type={fieldInfo.type}&#10;                          placeholder={fieldInfo.placeholder}&#10;                          className={inputStyle}&#10;                        /&gt;&#10;                      )}&#10;                    &lt;/FormControl&gt;&#10;                    &lt;FormMessage className=&quot;text-red-500 text-sm ml-2 mt-1&quot; /&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/FormItem&gt;&#10;              )}&#10;            /&gt;&#10;          ))}&#10;        &lt;/fieldset&gt;&#10;&#10;        &lt;fieldset className=&quot;flex flex-col mt-6&quot;&gt;&#10;          &lt;legend className=&quot;sr-only&quot;&gt;약관 동의&lt;/legend&gt;&#10;&#10;          &lt;FormField&#10;            control={control}&#10;            name=&quot;privacyAgree1&quot;&#10;            render={({ field }) =&gt; (&#10;              &lt;FormItem className=&quot;mb-4&quot;&gt;&#10;                &lt;div className=&quot;flex items-center&quot;&gt;&#10;                  &lt;FormControl&gt;&#10;                    &lt;Checkbox&#10;                      checked={field.value}&#10;                      onCheckedChange={field.onChange}&#10;                      id=&quot;privacy-agree1&quot;&#10;                      className=&quot;w-4 h-4 data-[state=checked]:bg-[#20242B] data-[state=checked]:text-white mr-2&quot;&#10;                      aria-describedby=&quot;privacy-agree1-desc&quot;&#10;                    /&gt;&#10;                  &lt;/FormControl&gt;&#10;                  &lt;FormLabel&#10;                    htmlFor=&quot;privacy-agree1&quot;&#10;                    className=&quot;text-sm font-normal text-[#B5BBC7] cursor-pointer&quot;&#10;                  &gt;&#10;                    &lt;span className=&quot;text-[#6A7181]&quot; aria-label=&quot;필수&quot;&gt;&#10;                      [필수]{&quot; &quot;}&#10;                    &lt;/span&gt;&#10;                    &lt;span id=&quot;privacy-agree1-desc&quot;&gt;이용약관 동의&lt;/span&gt;&#10;                  &lt;/FormLabel&gt;&#10;                &lt;/div&gt;&#10;                &lt;FormMessage className=&quot;text-red-500 text-sm pl-6&quot; /&gt;&#10;              &lt;/FormItem&gt;&#10;            )}&#10;          /&gt;&#10;&#10;          &lt;FormField&#10;            control={control}&#10;            name=&quot;privacyAgree2&quot;&#10;            render={({ field }) =&gt; (&#10;              &lt;FormItem&gt;&#10;                &lt;div className=&quot;flex items-center&quot;&gt;&#10;                  &lt;FormControl&gt;&#10;                    &lt;Checkbox&#10;                      checked={field.value}&#10;                      onCheckedChange={field.onChange}&#10;                      id=&quot;privacy-agree2&quot;&#10;                      className=&quot;w-4 h-4 data-[state=checked]:bg-[#20242B] data-[state=checked]:text-white mr-2&quot;&#10;                      aria-describedby=&quot;privacy-agree2-desc&quot;&#10;                    /&gt;&#10;                  &lt;/FormControl&gt;&#10;                  &lt;FormLabel&#10;                    htmlFor=&quot;privacy-agree2&quot;&#10;                    className=&quot;text-sm font-normal text-[#B5BBC7] cursor-pointer&quot;&#10;                  &gt;&#10;                    &lt;span className=&quot;text-[#6A7181]&quot; aria-label=&quot;필수&quot;&gt;&#10;                      [필수]{&quot; &quot;}&#10;                    &lt;/span&gt;&#10;                    &lt;span id=&quot;privacy-agree2-desc&quot;&gt;&#10;                      개인정보 수집 및 이용 동의&#10;                    &lt;/span&gt;&#10;                  &lt;/FormLabel&gt;&#10;                &lt;/div&gt;&#10;                &lt;FormMessage className=&quot;text-red-500 text-sm pl-6&quot; /&gt;&#10;              &lt;/FormItem&gt;&#10;            )}&#10;          /&gt;&#10;        &lt;/fieldset&gt;&#10;&#10;        &lt;div className=&quot;mt-10&quot;&gt;&#10;          &lt;Button&#10;            type=&quot;submit&quot;&#10;            className=&quot;w-full h-12 rounded-full bg-[#20242B] text-white text-base disabled:bg-[#F2F4F6] disabled:text-[#B5BBC7]&quot;&#10;            disabled={!isValid}&#10;            aria-label=&quot;회원가입 완료&quot;&#10;          &gt;&#10;            가입 완료&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/form&gt;&#10;    &lt;/Form&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import { Checkbox } from &quot;@/components/ui/checkbox&quot;;&#10;import {&#10;  Form,&#10;  FormControl,&#10;  FormField,&#10;  FormItem,&#10;  FormLabel,&#10;  FormMessage,&#10;} from &quot;@/components/ui/form&quot;;&#10;import { Input } from &quot;@/components/ui/input&quot;;&#10;import {&#10;  Select,&#10;  SelectContent,&#10;  SelectItem,&#10;  SelectTrigger,&#10;  SelectValue,&#10;} from &quot;@/components/ui/select&quot;;&#10;import signupFields from &quot;@/constants/signupFields&quot;;&#10;import { SignupFormValues } from &quot;@/lib/schemas/signupSchema&quot;;&#10;import { UseFormReturn } from &quot;react-hook-form&quot;;&#10;&#10;const inputStyle =&#10;  &quot;flex items-center rounded-full px-6 h-12 border border-[#F2F4F6] outline-none text-[#222] placeholder:text-[#D9D9D9] text-base bg-transparent w-full focus:ring-2 focus:ring-[#20242B]/20 transition&quot;;&#10;&#10;interface SignupFormProps {&#10;  form: UseFormReturn&lt;SignupFormValues&gt;;&#10;  onSubmitAction: (data: SignupFormValues) =&gt; void;&#10;  isValid: boolean;&#10;}&#10;&#10;export default function SignupForm({ form, onSubmitAction, isValid }: SignupFormProps) {&#10;  const { handleSubmit, control } = form;&#10;&#10;  return (&#10;    &lt;Form {...form}&gt;&#10;      &lt;form&#10;        className=&quot;w-[380px] max-w-md flex flex-col&quot;&#10;        onSubmit={handleSubmit(onSubmitAction)}&#10;        noValidate&#10;        aria-label=&quot;회원가입 양식&quot;&#10;      &gt;&#10;        &lt;fieldset className=&quot;flex flex-col gap-6 border-b border-[#F2F4F6] pb-10&quot;&gt;&#10;          &lt;legend className=&quot;sr-only&quot;&gt;회원 정보 입력&lt;/legend&gt;&#10;&#10;          {signupFields.map((fieldInfo) =&gt; (&#10;            &lt;FormField&#10;              key={fieldInfo.id}&#10;              control={control}&#10;              name={fieldInfo.id as keyof SignupFormValues}&#10;              render={({ field }) =&gt; (&#10;                &lt;FormItem className=&quot;flex items-center&quot;&gt;&#10;                  &lt;FormLabel className=&quot;text-[#B5BBC7] text-base w-25&quot;&gt;&#10;                    {fieldInfo.label}&#10;                  &lt;/FormLabel&gt;&#10;                  &lt;div className=&quot;w-full&quot;&gt;&#10;                    &lt;FormControl&gt;&#10;                      {fieldInfo.type === &quot;option&quot; ? (&#10;                        &lt;Select&#10;                          onValueChange={field.onChange}&#10;                          value={field.value as string}&#10;                          name={field.name}&#10;                        &gt;&#10;                          &lt;SelectTrigger className={inputStyle}&gt;&#10;                            &lt;SelectValue placeholder={fieldInfo.placeholder} /&gt;&#10;                          &lt;/SelectTrigger&gt;&#10;                          &lt;SelectContent&gt;&#10;                            {fieldInfo.options?.map((option: string) =&gt; (&#10;                              &lt;SelectItem key={option} value={option}&gt;&#10;                                {option}&#10;                              &lt;/SelectItem&gt;&#10;                            ))}&#10;                          &lt;/SelectContent&gt;&#10;                        &lt;/Select&gt;&#10;                      ) : (&#10;                        &lt;Input&#10;                          {...field}&#10;                          name={field.name}&#10;                          value={String(field.value ?? &quot;&quot;)}&#10;                          type={fieldInfo.type}&#10;                          placeholder={fieldInfo.placeholder}&#10;                          className={inputStyle}&#10;                        /&gt;&#10;                      )}&#10;                    &lt;/FormControl&gt;&#10;                    &lt;FormMessage className=&quot;text-red-500 text-sm ml-2 mt-1&quot; /&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/FormItem&gt;&#10;              )}&#10;            /&gt;&#10;          ))}&#10;        &lt;/fieldset&gt;&#10;&#10;        &lt;fieldset className=&quot;flex flex-col mt-6&quot;&gt;&#10;          &lt;legend className=&quot;sr-only&quot;&gt;약관 동의&lt;/legend&gt;&#10;&#10;          &lt;FormField&#10;            control={control}&#10;            name=&quot;privacyAgree1&quot;&#10;            render={({ field }) =&gt; (&#10;              &lt;FormItem className=&quot;mb-4&quot;&gt;&#10;                &lt;div className=&quot;flex items-center&quot;&gt;&#10;                  &lt;FormControl&gt;&#10;                    &lt;Checkbox&#10;                      checked={field.value}&#10;                      onCheckedChange={field.onChange}&#10;                      id=&quot;privacy-agree1&quot;&#10;                      className=&quot;w-4 h-4 data-[state=checked]:bg-[#20242B] data-[state=checked]:text-white mr-2&quot;&#10;                      aria-describedby=&quot;privacy-agree1-desc&quot;&#10;                    /&gt;&#10;                  &lt;/FormControl&gt;&#10;                  &lt;FormLabel&#10;                    htmlFor=&quot;privacy-agree1&quot;&#10;                    className=&quot;text-sm font-normal text-[#B5BBC7] cursor-pointer&quot;&#10;                  &gt;&#10;                    &lt;span className=&quot;text-[#6A7181]&quot; aria-label=&quot;필수&quot;&gt;&#10;                      [필수]{&quot; &quot;}&#10;                    &lt;/span&gt;&#10;                    &lt;span id=&quot;privacy-agree1-desc&quot;&gt;이용약관 동의&lt;/span&gt;&#10;                  &lt;/FormLabel&gt;&#10;                &lt;/div&gt;&#10;                &lt;FormMessage className=&quot;text-red-500 text-sm pl-6&quot; /&gt;&#10;              &lt;/FormItem&gt;&#10;            )}&#10;          /&gt;&#10;&#10;          &lt;FormField&#10;            control={control}&#10;            name=&quot;privacyAgree2&quot;&#10;            render={({ field }) =&gt; (&#10;              &lt;FormItem&gt;&#10;                &lt;div className=&quot;flex items-center&quot;&gt;&#10;                  &lt;FormControl&gt;&#10;                    &lt;Checkbox&#10;                      checked={field.value}&#10;                      onCheckedChange={field.onChange}&#10;                      id=&quot;privacy-agree2&quot;&#10;                      className=&quot;w-4 h-4 data-[state=checked]:bg-[#20242B] data-[state=checked]:text-white mr-2&quot;&#10;                      aria-describedby=&quot;privacy-agree2-desc&quot;&#10;                    /&gt;&#10;                  &lt;/FormControl&gt;&#10;                  &lt;FormLabel&#10;                    htmlFor=&quot;privacy-agree2&quot;&#10;                    className=&quot;text-sm font-normal text-[#B5BBC7] cursor-pointer&quot;&#10;                  &gt;&#10;                    &lt;span className=&quot;text-[#6A7181]&quot; aria-label=&quot;필수&quot;&gt;&#10;                      [필수]{&quot; &quot;}&#10;                    &lt;/span&gt;&#10;                    &lt;span id=&quot;privacy-agree2-desc&quot;&gt;&#10;                      개인정보 수집 및 이용 동의&#10;                    &lt;/span&gt;&#10;                  &lt;/FormLabel&gt;&#10;                &lt;/div&gt;&#10;                &lt;FormMessage className=&quot;text-red-500 text-sm pl-6&quot; /&gt;&#10;              &lt;/FormItem&gt;&#10;            )}&#10;          /&gt;&#10;        &lt;/fieldset&gt;&#10;&#10;        &lt;div className=&quot;mt-10&quot;&gt;&#10;          &lt;Button&#10;            type=&quot;submit&quot;&#10;            className=&quot;w-full h-12 rounded-full bg-[#20242B] text-white text-base disabled:bg-[#F2F4F6] disabled:text-[#B5BBC7]&quot;&#10;            disabled={!isValid}&#10;            aria-label=&quot;회원가입 완료&quot;&#10;          &gt;&#10;            가입 완료&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/form&gt;&#10;    &lt;/Form&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/features/comments/CommentCard.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/features/comments/CommentCard.tsx" />
              <option name="originalContent" value="/**&#10; * 댓글 카드 컴포넌트&#10; * &#10; * TanStack Query의 useDeleteComment 뮤테이션을 사용하여&#10; * 댓글 삭제 시 Optimistic Update와 자동 캐시 관리를 제공합니다.&#10; */&#10;&#10;import { useDeleteComment } from &quot;@/hooks/queries/useCommentQueries&quot;;&#10;import { MyCommentData, PostCommentData, isMyComment } from &quot;@/types/comment&quot;;&#10;import { DropdownActionItem } from &quot;@/types/dropdown&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import { useAuth } from &quot;../../../hooks/queries/useUserQueries&quot;;&#10;import { DropdownMenuList } from &quot;../../common/DropdownMenuList&quot;;&#10;&#10;interface CommentCardProps {&#10;  comment: PostCommentData | MyCommentData;&#10;  postId: number; // TanStack Query 뮤테이션에 필요&#10;  onCommentDeleted?: (commentId: number) =&gt; void; // 이제 선택사항 (TanStack Query가 자동 처리)&#10;}&#10;&#10;export default function CommentCard({ comment, postId, onCommentDeleted }: CommentCardProps) {&#10;  /**&#10;   * TanStack Query 뮤테이션을 사용한 댓글 삭제&#10;   * &#10;   * 이 훅은 다음 기능들을 자동으로 제공합니다:&#10;   * - Optimistic Update: 서버 응답 전에 UI에서 댓글 즉시 제거&#10;   * - 에러 처리: 실패 시 이전 상태로 자동 롤백&#10;   * - 로딩 상태: isPending을 통한 UI 비활성화&#10;   * - 캐시 갱신: 성공 시 관련 쿼리 자동 무효화&#10;   */&#10;&#10;  const { userProfile } = useAuth();&#10;&#10;  const deleteCommentMutation = useDeleteComment(postId);&#10;&#10;  const handleCommentEdit = () =&gt; {&#10;    if (deleteCommentMutation.isPending) return;&#10;    // TODO: Implement edit functionality&#10;    alert(`댓글 수정 기능 (ID: ${comment.commentId})`);&#10;  };&#10;&#10;  const handleCommentDelete = async () =&gt; {&#10;    if (deleteCommentMutation.isPending) return;&#10;&#10;    const confirmDelete = window.confirm(&#10;      `'${comment.content.substring(0, 30).trim()}${comment.content.length &gt; 30 ? &quot;...&quot; : &quot;&quot;}' 댓글을 정말 삭제하시겠습니까?`&#10;    );&#10;    if (!confirmDelete) {&#10;      return;&#10;    }&#10;&#10;    // TanStack Query 뮤테이션 실행&#10;    try {&#10;      await deleteCommentMutation.mutateAsync(comment.commentId);&#10;&#10;      // 기존 prop 콜백이 있다면 호출 (하위 호환성)&#10;      if (onCommentDeleted) {&#10;        onCommentDeleted(comment.commentId);&#10;      }&#10;&#10;    } catch (error) {&#10;      // 에러는 TanStack Query의 onError에서 이미 처리됨&#10;      // 추가 사용자 피드백이 필요하면 여기에 추가&#10;      console.error(&quot;댓글 삭제 실패:&quot;, error);&#10;      alert(&quot;댓글 삭제 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.&quot;);&#10;    }&#10;  };&#10;&#10;  const commentDropdownItems: DropdownActionItem[] = [&#10;    {&#10;      label: &quot;수정하기&quot;,&#10;      onClick: handleCommentEdit,&#10;      className: deleteCommentMutation.isPending ? &quot;text-gray-400 cursor-not-allowed&quot; : &quot;&quot;,&#10;    },&#10;  ];&#10;&#10;  const commentTriggerElement = (&#10;    &lt;button&#10;      type=&quot;button&quot;&#10;      aria-label=&quot;댓글 옵션 더보기&quot;&#10;      className={`p-1 hover:cursor-pointer hover:opacity-80 ${deleteCommentMutation.isPending ? &quot;cursor-not-allowed&quot; : &quot;&quot;}`}&#10;    &gt;&#10;      &lt;Image&#10;        src=&quot;/dot3.svg&quot;&#10;        alt=&quot;더보기&quot; // 버튼에 aria-label이 있으므로 alt는 간결하게&#10;        width={18}&#10;        height={4}&#10;      /&gt;&#10;    &lt;/button&gt;&#10;  );&#10;&#10;  // 현재 사용자가 댓글 작성자인지 확인하는 로직&#10;  const isCurrentUserCommentOwner = (() =&gt; {&#10;    // 실제 서버 연동 시에는 사용자 정보와 댓글 작성자 비교&#10;    if (!userProfile) return false;&#10;&#10;    // PostCommentData인 경우 writer 속성으로 비교&#10;    if ('writer' in comment) {&#10;      return comment.writer === userProfile.nickname;&#10;    }&#10;&#10;    // MyCommentData인 경우는 항상 현재 사용자의 댓글이므로 true&#10;    return true;&#10;  })();&#10;&#10;  if (isCurrentUserCommentOwner) {&#10;    commentDropdownItems.push({&#10;      label: deleteCommentMutation.isPending ? &quot;삭제 중...&quot; : &quot;삭제하기&quot;,&#10;      onClick: handleCommentDelete,&#10;      className: `w-full text-left ${deleteCommentMutation.isPending ? &quot;text-gray-400 cursor-not-allowed&quot; : &quot;text-red-600 hover:text-red-700 focus:text-red-700 hover:bg-red-50 focus:bg-red-50&quot;}`,&#10;    });&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-[#FAFBFF] w-full rounded-xl px-6 py-5&quot;&gt;&#10;      &lt;div className=&quot;relative&quot;&gt;&#10;        {isCurrentUserCommentOwner &amp;&amp; commentDropdownItems.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;absolute top-0 right-0&quot;&gt;&#10;            &lt;DropdownMenuList&#10;              triggerElement={commentTriggerElement}&#10;              items={commentDropdownItems}&#10;              contentClassName=&quot;w-28&quot;&#10;            /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {!isMyComment(comment) &amp;&amp; (&#10;        &lt;div className=&quot;flex items-center gap-2 mt-1&quot;&gt;&#10;          &lt;div className=&quot;w-9 h-9 rounded-full overflow-hidden mr-2&quot;&gt;&#10;            &lt;Image&#10;              src={comment.writerProfileImageUrl}&#10;              alt={`사용자 프로필 이미지`}&#10;              width={36}&#10;              height={36}&#10;              className=&quot;w-full h-full object-cover&quot;&#10;            /&gt;&#10;          &lt;/div&gt;&#10;          &lt;span className=&quot;text-[14px] font-medium text-[#1C222E]&quot;&gt;&#10;            {'writer' in comment ? comment.writer : userProfile?.nickname || &quot;나&quot;}&#10;          &lt;/span&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      &lt;div className=&quot;mt-2 text-[14px] text-[#464C58]&quot;&gt;&#10;        {comment.content}&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;mt-2 text-[12px] text-[#B5BBC7]&quot;&gt;&#10;        &lt;time dateTime={new Date(comment.createdAt).toISOString()}&gt;&#10;          {new Date(comment.createdAt).toLocaleDateString('ko-KR', {&#10;            year: 'numeric',&#10;            month: '2-digit',&#10;            day: '2-digit',&#10;            hour: '2-digit',&#10;            minute: '2-digit',&#10;            hour12: false&#10;          })}&#10;        &lt;/time&gt;&#10;        {/* &lt;span&gt; | &lt;/span&gt;&#10;        &lt;span&gt;답글&lt;/span&gt; */}&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;mt-2 text-[12px] text-[#B5BBC7]&quot;&gt;&#10;        {/* 게시글 제목 - MyCommentData인 경우에만 표시 (클릭 가능한 링크) */}&#10;        {isMyComment(comment) &amp;&amp; (&#10;          &lt;Link href={`/posts/${comment.postId}`} className=&quot;underline&quot;&gt;&#10;            {comment.postTitle}&#10;          &lt;/Link&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="/**&#10; * 댓글 카드 컴포넌트&#10; * &#10; * TanStack Query의 useDeleteComment 뮤테이션을 사용하여&#10; * 댓글 삭제 시 Optimistic Update와 자동 캐시 관리를 제공합니다.&#10; */&#10;&#10;import { useDeleteComment } from &quot;@/hooks/queries/useCommentQueries&quot;;&#10;import { CommentResponse } from &quot;@/generated/api&quot;;&#10;import { DropdownActionItem } from &quot;@/types/dropdown&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import { useAuth } from &quot;@/hooks/queries/useUserQueries&quot;;&#10;import { DropdownMenuList } from &quot;@/components/common/DropdownMenuList&quot;;&#10;&#10;interface CommentCardProps {&#10;  comment: CommentResponse;&#10;  postId: number; // TanStack Query 뮤테이션에 필요&#10;  onCommentDeleted?: (commentId: number) =&gt; void; // 이제 선택사항 (TanStack Query가 자동 처리)&#10;}&#10;&#10;export default function CommentCard({ comment, postId, onCommentDeleted }: CommentCardProps) {&#10;  /**&#10;   * TanStack Query 뮤테이션을 사용한 댓글 삭제&#10;   * &#10;   * 이 훅은 다음 기능들을 자동으로 제공합니다:&#10;   * - Optimistic Update: 서버 응답 전에 UI에서 댓글 즉시 제거&#10;   * - 에러 처리: 실패 시 이전 상태로 자동 롤백&#10;   * - 로딩 상태: isPending을 통한 UI 비활성화&#10;   * - 캐시 갱신: 성공 시 관련 쿼리 자동 무효화&#10;   */&#10;&#10;  const { userProfile } = useAuth();&#10;&#10;  const deleteCommentMutation = useDeleteComment(postId);&#10;&#10;  const handleCommentEdit = () =&gt; {&#10;    if (deleteCommentMutation.isPending) return;&#10;    // TODO: Implement edit functionality&#10;    alert(`댓글 수정 기능 (ID: ${comment.commentId})`);&#10;  };&#10;&#10;  const handleCommentDelete = async () =&gt; {&#10;    if (deleteCommentMutation.isPending) return;&#10;&#10;    const confirmDelete = window.confirm(&#10;      `'${comment.content.substring(0, 30).trim()}${comment.content.length &gt; 30 ? &quot;...&quot; : &quot;&quot;}' 댓글을 정말 삭제하시겠습니까?`&#10;    );&#10;    if (!confirmDelete) {&#10;      return;&#10;    }&#10;&#10;    // TanStack Query 뮤테이션 실행&#10;    try {&#10;      await deleteCommentMutation.mutateAsync(comment.commentId);&#10;&#10;      // 기존 prop 콜백이 있다면 호출 (하위 호환성)&#10;      if (onCommentDeleted) {&#10;        onCommentDeleted(comment.commentId);&#10;      }&#10;&#10;    } catch (error) {&#10;      // 에러는 TanStack Query의 onError에서 이미 처리됨&#10;      // 추가 사용자 피드백이 필요하면 여기에 추가&#10;      console.error(&quot;댓글 삭제 실패:&quot;, error);&#10;      alert(&quot;댓글 삭제 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.&quot;);&#10;    }&#10;  };&#10;&#10;  const commentDropdownItems: DropdownActionItem[] = [&#10;    {&#10;      label: &quot;수정하기&quot;,&#10;      onClick: handleCommentEdit,&#10;      className: deleteCommentMutation.isPending ? &quot;text-gray-400 cursor-not-allowed&quot; : &quot;&quot;,&#10;    },&#10;  ];&#10;&#10;  const commentTriggerElement = (&#10;    &lt;button&#10;      type=&quot;button&quot;&#10;      aria-label=&quot;댓글 옵션 더보기&quot;&#10;      className={`p-1 hover:cursor-pointer hover:opacity-80 ${deleteCommentMutation.isPending ? &quot;cursor-not-allowed&quot; : &quot;&quot;}`}&#10;    &gt;&#10;      &lt;Image&#10;        src=&quot;/dot3.svg&quot;&#10;        alt=&quot;더보기&quot; // 버튼에 aria-label이 있으므로 alt는 간결하게&#10;        width={18}&#10;        height={4}&#10;      /&gt;&#10;    &lt;/button&gt;&#10;  );&#10;&#10;  // 현재 사용자가 댓글 작성자인지 확인하는 로직&#10;  const isCurrentUserCommentOwner = (() =&gt; {&#10;    if (!userProfile) return false;&#10;    // CommentResponse는 항상 writer 속성을 가지므로 직접 비교&#10;    return comment.writer === userProfile.nickname;&#10;  })();&#10;&#10;  if (isCurrentUserCommentOwner) {&#10;    commentDropdownItems.push({&#10;      label: deleteCommentMutation.isPending ? &quot;삭제 중...&quot; : &quot;삭제하기&quot;,&#10;      onClick: handleCommentDelete,&#10;      className: `w-full text-left ${deleteCommentMutation.isPending ? &quot;text-gray-400 cursor-not-allowed&quot; : &quot;text-red-600 hover:text-red-700 focus:text-red-700 hover:bg-red-50 focus:bg-red-50&quot;}`,&#10;    });&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;bg-[#FAFBFF] w-full rounded-xl px-6 py-5&quot;&gt;&#10;      &lt;div className=&quot;relative&quot;&gt;&#10;        {isCurrentUserCommentOwner &amp;&amp; commentDropdownItems.length &gt; 0 &amp;&amp; (&#10;          &lt;div className=&quot;absolute top-0 right-0&quot;&gt;&#10;            &lt;DropdownMenuList&#10;              triggerElement={commentTriggerElement}&#10;              items={commentDropdownItems}&#10;              contentClassName=&quot;w-28&quot;&#10;            /&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      {/* 사용자 프로필 정보 표시 */}&#10;      &lt;div className=&quot;flex items-center gap-2 mt-1&quot;&gt;&#10;        &lt;div className=&quot;w-9 h-9 rounded-full overflow-hidden mr-2&quot;&gt;&#10;          &lt;Image&#10;            src={comment.writerProfileImageUrl || &quot;/profileSVG.svg&quot;}&#10;            alt={`${comment.writer}의 프로필 이미지`}&#10;            width={36}&#10;            height={36}&#10;            className=&quot;w-full h-full object-cover&quot;&#10;          /&gt;&#10;        &lt;/div&gt;&#10;        &lt;span className=&quot;text-[14px] font-medium text-[#1C222E]&quot;&gt;&#10;          {comment.writer}&#10;        &lt;/span&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;mt-2 text-[14px] text-[#464C58]&quot;&gt;&#10;        {comment.content}&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;mt-2 text-[12px] text-[#B5BBC7]&quot;&gt;&#10;        &lt;time dateTime={new Date(comment.createdAt).toISOString()}&gt;&#10;          {new Date(comment.createdAt).toLocaleDateString('ko-KR', {&#10;            year: 'numeric',&#10;            month: '2-digit',&#10;            day: '2-digit',&#10;            hour: '2-digit',&#10;            minute: '2-digit',&#10;            hour12: false&#10;          })}&#10;        &lt;/time&gt;&#10;        {/* &lt;span&gt; | &lt;/span&gt;&#10;        &lt;span&gt;답글&lt;/span&gt; */}&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;mt-2 text-[12px] text-[#B5BBC7]&quot;&gt;&#10;        {/* 게시글 제목 링크 - 필요한 경우에만 표시 */}&#10;        {comment.postTitle &amp;&amp; (&#10;          &lt;Link href={`/posts/${comment.postId}`} className=&quot;underline&quot;&gt;&#10;            {comment.postTitle}&#10;          &lt;/Link&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/features/comments/CommentForm.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/features/comments/CommentForm.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 댓글 작성 폼 컴포넌트&#10; * &#10; * TanStack Query의 useMutation을 사용하여 댓글 등록을 처리합니다.&#10; * Optimistic Update를 통해 서버 응답 전에 UI를 먼저 업데이트하여 &#10; * 더 빠른 사용자 경험을 제공합니다.&#10; */&#10;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import { useCreateComment } from &quot;@/hooks/queries/useCommentQueries&quot;;&#10;import { useAuth } from &quot;@/hooks/queries/useUserQueries&quot;;&#10;import { CommentData } from &quot;@/types/comment&quot;;&#10;import Image from 'next/image';&#10;import { FormEvent, useState } from &quot;react&quot;;&#10;&#10;interface CommentFormProps {&#10;  postId: number;&#10;  onCommentSubmitted?: (newComment: CommentData) =&gt; void; // 이제 선택사항 (TanStack Query가 자동 처리)&#10;}&#10;&#10;export default function CommentForm({ postId, onCommentSubmitted }: CommentFormProps) {&#10;  const [newComment, setNewComment] = useState(&quot;&quot;);&#10;  const { userProfile } = useAuth();&#10;&#10;  /**&#10;   * TanStack Query 뮤테이션을 사용한 댓글 등록&#10;   * &#10;   * 이 훅은 다음 기능들을 자동으로 제공합니다:&#10;   * - Optimistic Update: 서버 응답 전에 UI 즉시 업데이트&#10;   * - 에러 처리: 실패 시 이전 상태로 자동 롤백&#10;   * - 로딩 상태: isLoading을 통한 버튼 비활성화&#10;   * - 캐시 갱신: 성공 시 관련 쿼리 자동 무효화&#10;   */&#10;  const createCommentMutation = useCreateComment(postId);&#10;&#10;  const handleSubmit = async (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; {&#10;    event.preventDefault();&#10;&#10;    if (!newComment.trim()) {&#10;      alert(&quot;댓글 내용을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    // TanStack Query 뮤테이션 실행&#10;    try {&#10;      const result = await createCommentMutation.mutateAsync({&#10;        content: newComment.trim(),&#10;        parentCommentId: undefined, // 현재는 최상위 댓글만 지원&#10;      });&#10;&#10;      // 성공 시 폼 초기화&#10;      setNewComment(&quot;&quot;);&#10;&#10;      // 기존 prop 콜백이 있다면 호출 (하위 호환성)&#10;      if (onCommentSubmitted) {&#10;        onCommentSubmitted(result);&#10;      }&#10;&#10;    } catch (error) {&#10;      // 에러는 TanStack Query의 onError에서 이미 처리됨&#10;      // 추가 사용자 피드백이 필요하면 여기에 추가&#10;      console.error('댓글 등록 중 오류:', error);&#10;      alert(&quot;댓글 작성에 실패했습니다. 다시 시도해주세요.&quot;);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;form className=&quot;mt-4 flex flex-col gap-3&quot; onSubmit={handleSubmit} aria-label=&quot;댓글 작성&quot;&gt;&#10;      &lt;div className=&quot;flex items-start gap-3&quot;&gt;&#10;        &lt;div className=&quot;w-9 h-9 rounded-full overflow-hidden shrink-0&quot;&gt;&#10;          &lt;Image&#10;            src={userProfile?.profileImageUrl || &quot;/profileSVG.svg&quot;}&#10;            alt=&quot;현재 사용자의 프로필 이미지&quot;&#10;            width={36}&#10;            height={36}&#10;            className=&quot;w-full h-full object-cover&quot;&#10;          /&gt;&#10;        &lt;/div&gt;&#10;        &lt;textarea&#10;          id=&quot;comment-input&quot;&#10;          placeholder=&quot;댓글을 남겨주세요.&quot;&#10;          className=&quot;border border-[#E7EEFE] rounded-xl w-full px-5 py-3.5 text-sm text-gray-800 focus:outline-none focus:ring-2 focus:ring-[#FAA631]/50 transition resize-none min-h-[80px]&quot;&#10;          aria-required=&quot;true&quot;&#10;          value={newComment}&#10;          onChange={(e) =&gt; setNewComment(e.target.value)}&#10;          disabled={createCommentMutation.isPending} // TanStack Query 로딩 상태 사용&#10;        /&gt;&#10;      &lt;/div&gt;&#10;      &lt;div className=&quot;flex justify-end&quot;&gt;&#10;        &lt;Button&#10;          type=&quot;submit&quot;&#10;          className=&quot;rounded-[63px] bg-[#20242B] px-3 py-1.5 text-white hover:bg-[#1C222E] text-[12px]&quot;&#10;          disabled={createCommentMutation.isPending} // TanStack Query 로딩 상태 사용&#10;        &gt;&#10;          {createCommentMutation.isPending ? &quot;등록 중...&quot; : &quot;등록&quot;}&#10;        &lt;/Button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/form&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;/**&#13;&#10; * 댓글 작성 폼 컴포넌트&#13;&#10; * &#13;&#10; * TanStack Query의 useMutation을 사용하여 댓글 등록을 처리합니다.&#13;&#10; * Optimistic Update를 통해 서버 응답 전에 UI를 먼저 업데이트하여 &#13;&#10; * 더 빠른 사용자 경험을 제공합니다.&#13;&#10; */&#13;&#10;&#13;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#13;&#10;import { useCreateComment } from &quot;@/hooks/queries/useCommentQueries&quot;;&#13;&#10;import { useAuth } from &quot;@/hooks/queries/useUserQueries&quot;;&#13;&#10;import { CommentResponse } from &quot;@/generated/api&quot;;&#13;&#10;import Image from 'next/image';&#13;&#10;import { FormEvent, useState } from &quot;react&quot;;&#13;&#10;&#13;&#10;interface CommentFormProps {&#13;&#10;  postId: number;&#13;&#10;  onCommentSubmitted?: (newComment: CommentResponse) =&gt; void; // 이제 선택사항 (TanStack Query가 자동 처리)&#13;&#10;}&#13;&#10;&#13;&#10;export default function CommentForm({ postId, onCommentSubmitted }: CommentFormProps) {&#13;&#10;  const [newComment, setNewComment] = useState(&quot;&quot;);&#13;&#10;  const { userProfile } = useAuth();&#13;&#10;&#13;&#10;  /**&#13;&#10;   * TanStack Query 뮤테이션을 사용한 댓글 등록&#13;&#10;   * &#13;&#10;   * 이 훅은 다음 기능들을 자동으로 제공합니다:&#13;&#10;   * - Optimistic Update: 서버 응답 전에 UI 즉시 업데이트&#13;&#10;   * - 에러 처리: 실패 시 이전 상태로 자동 롤백&#13;&#10;   * - 로딩 상태: isLoading을 통한 버튼 비활성화&#13;&#10;   * - 캐시 갱신: 성공 시 관련 쿼리 자동 무효화&#13;&#10;   */&#13;&#10;  const createCommentMutation = useCreateComment(postId);&#13;&#10;&#13;&#10;  const handleSubmit = async (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; {&#13;&#10;    event.preventDefault();&#13;&#10;&#13;&#10;    if (!newComment.trim()) {&#13;&#10;      alert(&quot;댓글 내용을 입력해주세요.&quot;);&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    // TanStack Query 뮤테이션 실행&#13;&#10;    try {&#13;&#10;      const result = await createCommentMutation.mutateAsync({&#13;&#10;        content: newComment.trim(),&#13;&#10;        parentCommentId: undefined, // 현재는 최상위 댓글만 지원&#13;&#10;      });&#13;&#10;&#13;&#10;      // 성공 시 폼 초기화&#13;&#10;      setNewComment(&quot;&quot;);&#13;&#10;&#13;&#10;      // 기존 prop 콜백이 있다면 호출 (하위 호환성)&#13;&#10;      if (onCommentSubmitted) {&#13;&#10;        onCommentSubmitted(result);&#13;&#10;      }&#13;&#10;&#13;&#10;    } catch (error) {&#13;&#10;      // 에러는 TanStack Query의 onError에서 이미 처리됨&#13;&#10;      // 추가 사용자 피드백이 필요하면 여기에 추가&#13;&#10;      console.error('댓글 등록 중 오류:', error);&#13;&#10;      alert(&quot;댓글 작성에 실패했습니다. 다시 시도해주세요.&quot;);&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;form className=&quot;mt-4 flex flex-col gap-3&quot; onSubmit={handleSubmit} aria-label=&quot;댓글 작성&quot;&gt;&#13;&#10;      &lt;div className=&quot;flex items-start gap-3&quot;&gt;&#13;&#10;        &lt;div className=&quot;w-9 h-9 rounded-full overflow-hidden shrink-0&quot;&gt;&#13;&#10;          &lt;Image&#13;&#10;            src={userProfile?.profileImageUrl || &quot;/profileSVG.svg&quot;}&#13;&#10;            alt=&quot;현재 사용자의 프로필 이미지&quot;&#13;&#10;            width={36}&#13;&#10;            height={36}&#13;&#10;            className=&quot;w-full h-full object-cover&quot;&#13;&#10;          /&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;        &lt;textarea&#13;&#10;          id=&quot;comment-input&quot;&#13;&#10;          placeholder=&quot;댓글을 남겨주세요.&quot;&#13;&#10;          className=&quot;border border-[#E7EEFE] rounded-xl w-full px-5 py-3.5 text-sm text-gray-800 focus:outline-none focus:ring-2 focus:ring-[#FAA631]/50 transition resize-none min-h-[80px]&quot;&#13;&#10;          aria-required=&quot;true&quot;&#13;&#10;          value={newComment}&#13;&#10;          onChange={(e) =&gt; setNewComment(e.target.value)}&#13;&#10;          disabled={createCommentMutation.isPending} // TanStack Query 로딩 상태 사용&#13;&#10;        /&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;      &lt;div className=&quot;flex justify-end&quot;&gt;&#13;&#10;        &lt;Button&#13;&#10;          type=&quot;submit&quot;&#13;&#10;          className=&quot;rounded-[63px] bg-[#20242B] px-3 py-1.5 text-white hover:bg-[#1C222E] text-[12px]&quot;&#13;&#10;          disabled={createCommentMutation.isPending} // TanStack Query 로딩 상태 사용&#13;&#10;        &gt;&#13;&#10;          {createCommentMutation.isPending ? &quot;등록 중...&quot; : &quot;등록&quot;}&#13;&#10;        &lt;/Button&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/form&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/features/comments/CommentList.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/features/comments/CommentList.tsx" />
              <option name="originalContent" value="import { CommentResponse } from &quot;@/generated/api&quot;;&#10;import CommentCard from &quot;./CommentCard&quot;;&#10;&#10;// 'my' variant에서 postTitle을 사용하기 위한 확장 타입&#10;type MyComment = CommentResponse &amp; {&#10;  postTitle?: string;&#10;};&#10;&#10;interface CommentListProps {&#10;  comments: (CommentResponse | MyComment)[];&#10;  postId?: number;&#10;  onCommentDeleted?: (commentId: number) =&gt; void;&#10;  variant?: 'post' | 'my';&#10;  className?: string;&#10;}&#10;&#10;export default function CommentList({&#10;  comments,&#10;  postId,&#10;  onCommentDeleted,&#10;  variant,&#10;  className = &quot;&quot;,&#10;}: CommentListProps) {&#10;  const resolvedVariant = variant || (postId !== undefined ? 'post' : 'my');&#10;  const reversedComments = [...comments].reverse();&#10;&#10;  if (!comments || comments.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;mt-8 text-center text-gray-500&quot;&gt;&#10;        &lt;p&gt;&#10;          {resolvedVariant === 'my'&#10;            ? '아직 작성한 댓글이 없어요. 다른 게시글에 댓글을 남겨보세요!'&#10;            : '아직 작성된 댓글이 없어요. 첫 댓글을 남겨주세요!'}&#10;        &lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className={`mt-8 flex flex-col gap-4 ${className}`}&gt;&#10;      {reversedComments.map((comment) =&gt; (&#10;        &lt;CommentCard&#10;          key={comment.commentId}&#10;          comment={comment}&#10;          // 'post' variant일 경우 부모로부터 받은 postId를, 'my' variant일 경우 comment에 포함된 postId를 사용&#10;          postId={resolvedVariant === 'post' ? postId! : comment.postId!}&#10;          onCommentDeleted={onCommentDeleted}&#10;        /&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="import { CommentResponse } from &quot;@/generated/api&quot;;&#10;import CommentCard from &quot;./CommentCard&quot;;&#10;&#10;// 'my' variant에서 postTitle과 postId를 사용하기 위한 확장 타입&#10;type MyComment = CommentResponse &amp; {&#10;  postTitle?: string;&#10;  postId?: number;&#10;};&#10;&#10;interface CommentListProps {&#10;  comments: (CommentResponse | MyComment)[];&#10;  postId?: number;&#10;  variant?: 'post' | 'my';&#10;  className?: string;&#10;}&#10;&#10;export default function CommentList({&#10;  comments,&#10;  postId,&#10;  variant,&#10;  className = &quot;&quot;,&#10;}: CommentListProps) {&#10;  const resolvedVariant = variant || (postId !== undefined ? 'post' : 'my');&#10;  const reversedComments = [...comments].reverse();&#10;&#10;  if (!comments || comments.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;mt-8 text-center text-gray-500&quot;&gt;&#10;        &lt;p&gt;&#10;          {resolvedVariant === 'my'&#10;            ? '아직 작성한 댓글이 없어요. 다른 게시글에 댓글을 남겨보세요!'&#10;            : '아직 작성된 댓글이 없어요. 첫 댓글을 남겨주세요!'}&#10;        &lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className={`mt-8 flex flex-col gap-4 ${className}`}&gt;&#10;      {reversedComments.map((comment) =&gt; (&#10;        &lt;CommentCard&#10;          key={comment.commentId}&#10;          comment={comment}&#10;          // 'post' variant일 경우 부모로부터 받은 postId를, 'my' variant일 경우 comment에 포함된 postId를 사용&#10;          postId={resolvedVariant === 'post' ? postId! : (comment as MyComment).postId!}&#10;        /&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/features/posts/PopularPostList.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/features/posts/PopularPostList.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 인기 게시글 목록 컴포넌트&#10; * &#10; * TanStack Query를 사용하여 인기 게시글 데이터를 &#10; * 자동으로 관리하고 로딩/에러 상태를 처리합니다.&#10; */&#10;&#10;import { usePopularPosts } from &quot;@/hooks/queries/usePostQueries&quot;;&#10;import PopularPost from './PopularPost';&#10;&#10;export default function PopularPostList() {&#10;  /**&#10;   * TanStack Query를 사용하여 인기 게시글 목록을 가져옵니다.&#10;   * &#10;   * 이 훅의 장점:&#10;   * - 자동 캐싱: 동일한 데이터를 여러 컴포넌트에서 공유&#10;   * - 백그라운드 갱신: 데이터가 오래되면 자동으로 업데이트&#10;   * - 로딩/에러 상태: 별도 state 관리 없이 자동 제공&#10;   * - 재시도 로직: 네트워크 오류 시 자동 재시도&#10;   */&#10;  const { data: posts, isLoading, error } = usePopularPosts();&#10;&#10;  return (&#10;    &lt;section&gt;&#10;      &lt;h3 className=&quot;text-[18px] text-[#838C9D] mb-7&quot;&gt;주간 인기 게시물&lt;/h3&gt;&#10;&#10;      {/* 로딩 상태 처리 */}&#10;      {isLoading &amp;&amp; (&#10;        &lt;div className=&quot;mt-7 space-y-4&quot;&gt;&#10;          {[...Array(3)].map((_, index) =&gt; (&#10;            &lt;div key={index} className=&quot;animate-pulse&quot;&gt;&#10;              &lt;div className=&quot;h-5 bg-gray-200 rounded w-3/4 mb-2&quot;&gt;&lt;/div&gt;&#10;              &lt;div className=&quot;h-4 bg-gray-200 rounded w-1/2&quot;&gt;&lt;/div&gt;&#10;            &lt;/div&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* 에러 상태 처리 */}&#10;      {error &amp;&amp; (&#10;        &lt;div className=&quot;mt-7 text-red-500 text-sm&quot;&gt;&#10;          &lt;p&gt;인기 게시글을 불러오는 중 오류가 발생했습니다.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* 성공 상태: 인기 게시글 목록 표시 */}&#10;      {posts &amp;&amp; !isLoading &amp;&amp; !error &amp;&amp; (&#10;        &lt;&gt;&#10;          {posts.map((post) =&gt; (&#10;            &lt;PopularPost key={post.postId} postId={post.postId} title={post.title} author={post.writer} profileImage={post.writerProfileImageUrl} /&gt;&#10;          ))}&#10;        &lt;/&gt;&#10;      )}&#10;&#10;      {/* 데이터가 없는 경우 */}&#10;      {posts &amp;&amp; posts.length === 0 &amp;&amp; !isLoading &amp;&amp; !error &amp;&amp; (&#10;        &lt;div className=&quot;mt-7 text-gray-500 text-sm&quot;&gt;&#10;          &lt;p&gt;인기 게시글이 없습니다.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/section&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 인기 게시글 목록 컴포넌트&#10; * &#10; * TanStack Query를 사용하여 인기 게시글 데이터를 &#10; * 자동으로 관리하고 로딩/에러 상태를 처리합니다.&#10; */&#10;&#10;import { usePopularPosts } from &quot;@/hooks/queries/usePostQueries&quot;;&#10;import PopularPost from './PopularPost';&#10;&#10;export default function PopularPostList() {&#10;  /**&#10;   * TanStack Query를 사용하여 인기 게시글 목록을 가져옵니다.&#10;   * &#10;   * 이 훅의 장점:&#10;   * - 자동 캐싱: 동일한 데이터를 여러 컴포넌트에서 공유&#10;   * - 백그라운드 갱신: 데이터가 오래되면 자동으로 업데이트&#10;   * - 로딩/에러 상태: 별도 state 관리 없이 자동 제공&#10;   * - 재시도 로직: 네트워크 오류 시 자동 재시도&#10;   */&#10;  const { data: posts, isLoading, error } = usePopularPosts();&#10;&#10;  return (&#10;    &lt;section&gt;&#10;      &lt;h3 className=&quot;text-[18px] text-[#838C9D] mb-7&quot;&gt;주간 인기 게시물&lt;/h3&gt;&#10;&#10;      {/* 로딩 상태 처리 */}&#10;      {isLoading &amp;&amp; (&#10;        &lt;div className=&quot;mt-7 space-y-4&quot;&gt;&#10;          {[...Array(3)].map((_, index) =&gt; (&#10;            &lt;div key={index} className=&quot;animate-pulse&quot;&gt;&#10;              &lt;div className=&quot;h-5 bg-gray-200 rounded w-3/4 mb-2&quot;&gt;&lt;/div&gt;&#10;              &lt;div className=&quot;h-4 bg-gray-200 rounded w-1/2&quot;&gt;&lt;/div&gt;&#10;            &lt;/div&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* 에러 상태 처리 */}&#10;      {error &amp;&amp; (&#10;        &lt;div className=&quot;mt-7 text-red-500 text-sm&quot;&gt;&#10;          &lt;p&gt;인기 게시글을 불러오는 중 오류가 발생했습니다.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* 성공 상태: 인기 게시글 목록 표시 */}&#10;      {posts &amp;&amp; !isLoading &amp;&amp; !error &amp;&amp; (&#10;        &lt;&gt;&#10;          {posts&#10;            .filter((post) =&gt; post.postId &amp;&amp; post.title &amp;&amp; post.writer) // 필수 데이터가 있는 게시글만 필터링&#10;            .map((post) =&gt; (&#10;              &lt;PopularPost &#10;                key={post.postId} &#10;                postId={post.postId!} &#10;                title={post.title!} &#10;                author={post.writer!} &#10;                profileImage={post.writerProfileImageUrl} &#10;              /&gt;&#10;            ))&#10;          }&#10;        &lt;/&gt;&#10;      )}&#10;&#10;      {/* 데이터가 없는 경우 */}&#10;      {posts &amp;&amp; posts.length === 0 &amp;&amp; !isLoading &amp;&amp; !error &amp;&amp; (&#10;        &lt;div className=&quot;mt-7 text-gray-500 text-sm&quot;&gt;&#10;          &lt;p&gt;인기 게시글이 없습니다.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/section&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/features/posts/PostCommentsSection.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/features/posts/PostCommentsSection.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 게시글 댓글 섹션 컴포넌트&#10; * &#10; * TanStack Query를 사용하여 댓글 데이터를 효율적으로 관리합니다.&#10; * usePost 훅을 통해 게시글 상세 정보 (댓글 포함)를 가져오고,&#10; * 댓글 추가/삭제는 자동으로 캐시가 업데이트됩니다.&#10; */&#10;&#10;import CommentList from &quot;@/components/features/comments/CommentList&quot;;&#10;import { usePost } from &quot;@/hooks/queries/usePostQueries&quot;;&#10;import { CommentData } from &quot;@/types/comment&quot;;&#10;import CommentForm from &quot;../comments/CommentForm&quot;;&#10;&#10;interface PostCommentsSectionProps {&#10;  postId: number;&#10;  initialComments?: CommentData[]; // 이제 선택사항 (TanStack Query가 관리)&#10;}&#10;&#10;export default function PostCommentsSection({&#10;  postId,&#10;  initialComments = [],&#10;}: PostCommentsSectionProps) {&#10;  /**&#10;   * TanStack Query를 사용하여 게시글 상세 정보를 가져옵니다.&#10;   * &#10;   * 이 훅의 장점:&#10;   * - 자동 캐싱: 동일한 게시글을 여러 컴포넌트에서 공유&#10;   * - 백그라운드 갱신: 댓글 변경 시 자동으로 최신 데이터 동기화&#10;   * - Optimistic Update: 댓글 추가/삭제 시 즉시 UI 반영&#10;   * - 에러 처리: 네트워크 오류 시 자동 재시도&#10;   */&#10;  const {&#10;    data: post,&#10;    isLoading,&#10;    error&#10;  } = usePost(postId);&#10;&#10;  // TanStack Query에서 가져온 데이터 우선 사용, 없으면 fallback 데이터 사용&#10;  const comments = post?.comments || initialComments;&#10;&#10;  // 로딩 중일 때 스켈레톤 UI 표시&#10;  if (isLoading) {&#10;    return (&#10;      &lt;section className=&quot;mt-12 text-[#353841] text-[17px]&quot; aria-label=&quot;댓글 섹션&quot;&gt;&#10;        &lt;div className=&quot;animate-pulse&quot;&gt;&#10;          &lt;div className=&quot;h-6 bg-gray-200 rounded w-32 mb-4&quot;&gt;&lt;/div&gt;&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            {[...Array(3)].map((_, index) =&gt; (&#10;              &lt;div key={index} className=&quot;bg-gray-100 rounded-xl px-6 py-5&quot;&gt;&#10;                &lt;div className=&quot;flex items-center gap-2 mb-2&quot;&gt;&#10;                  &lt;div className=&quot;w-9 h-9 bg-gray-200 rounded-full&quot;&gt;&lt;/div&gt;&#10;                  &lt;div className=&quot;h-4 bg-gray-200 rounded w-20&quot;&gt;&lt;/div&gt;&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;h-4 bg-gray-200 rounded w-full&quot;&gt;&lt;/div&gt;&#10;              &lt;/div&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/section&gt;&#10;    );&#10;  }&#10;&#10;  // 에러 발생 시 에러 메시지 표시&#10;  if (error) {&#10;    return (&#10;      &lt;section className=&quot;mt-12 text-[#353841] text-[17px]&quot; aria-label=&quot;댓글 섹션&quot;&gt;&#10;        &lt;h2 className=&quot;mt-7 text-lg font-semibold&quot;&gt;댓글&lt;/h2&gt;&#10;        &lt;div className=&quot;mt-4 text-center text-red-500&quot;&gt;&#10;          &lt;p&gt;댓글을 불러오는 중 오류가 발생했습니다.&lt;/p&gt;&#10;          &lt;p className=&quot;text-sm text-gray-500 mt-2&quot;&gt;{error.message}&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/section&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;section className=&quot;mt-12 text-[#353841] text-[17px] mx-4&quot; aria-label=&quot;댓글 섹션&quot;&gt;&#10;      {/* TanStack Query가 댓글 추가를 자동으로 처리하므로 onCommentSubmitted는 선택사항 */}&#10;      &lt;CommentForm postId={postId} /&gt;&#10;&#10;      {/* TanStack Query가 댓글 삭제를 자동으로 처리하므로 onCommentDeleted는 선택사항 */}&#10;      &lt;CommentList&#10;        comments={comments}&#10;        variant=&quot;post&quot;&#10;        postId={postId}&#10;      /&gt;&#10;    &lt;/section&gt;&#10;  );&#10;}" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;/**&#13;&#10; * 게시글 댓글 섹션 컴포넌트&#13;&#10; * &#13;&#10; * TanStack Query를 사용하여 댓글 데이터를 효율적으로 관리합니다.&#13;&#10; * usePost 훅을 통해 게시글 상세 정보 (댓글 포함)를 가져오고,&#13;&#10; * 댓글 추가/삭제는 자동으로 캐시가 업데이트됩니다.&#13;&#10; */&#13;&#10;&#13;&#10;import CommentList from &quot;@/components/features/comments/CommentList&quot;;&#13;&#10;import { usePost } from &quot;@/hooks/queries/usePostQueries&quot;;&#13;&#10;import { CommentResponse } from &quot;@/generated/api&quot;;&#13;&#10;import CommentForm from &quot;../comments/CommentForm&quot;;&#13;&#10;&#13;&#10;interface PostCommentsSectionProps {&#13;&#10;  postId: number;&#13;&#10;  initialComments?: CommentResponse[]; // 이제 선택사항 (TanStack Query가 관리)&#13;&#10;}&#13;&#10;&#13;&#10;export default function PostCommentsSection({&#13;&#10;  postId,&#13;&#10;  initialComments = [],&#13;&#10;}: PostCommentsSectionProps) {&#13;&#10;  /**&#13;&#10;   * TanStack Query를 사용하여 게시글 상세 정보를 가져옵니다.&#13;&#10;   * &#13;&#10;   * 이 훅의 장점:&#13;&#10;   * - 자동 캐싱: 동일한 게시글을 여러 컴포넌트에서 공유&#13;&#10;   * - 백그라운드 갱신: 댓글 변경 시 자동으로 최신 데이터 동기화&#13;&#10;   * - Optimistic Update: 댓글 추가/삭제 시 즉시 UI 반영&#13;&#10;   * - 에러 처리: 네트워크 오류 시 자동 재시도&#13;&#10;   */&#13;&#10;  const {&#13;&#10;    data: post,&#13;&#10;    isLoading,&#13;&#10;    error&#13;&#10;  } = usePost(postId);&#13;&#10;&#13;&#10;  // TanStack Query에서 가져온 데이터 우선 사용, 없으면 fallback 데이터 사용&#13;&#10;  const comments = post?.comments || initialComments;&#13;&#10;&#13;&#10;  // 로딩 중일 때 스켈레톤 UI 표시&#13;&#10;  if (isLoading) {&#13;&#10;    return (&#13;&#10;      &lt;section className=&quot;mt-12 text-[#353841] text-[17px]&quot; aria-label=&quot;댓글 섹션&quot;&gt;&#13;&#10;        &lt;div className=&quot;animate-pulse&quot;&gt;&#13;&#10;          &lt;div className=&quot;h-6 bg-gray-200 rounded w-32 mb-4&quot;&gt;&lt;/div&gt;&#13;&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#13;&#10;            {[...Array(3)].map((_, index) =&gt; (&#13;&#10;              &lt;div key={index} className=&quot;bg-gray-100 rounded-xl px-6 py-5&quot;&gt;&#13;&#10;                &lt;div className=&quot;flex items-center gap-2 mb-2&quot;&gt;&#13;&#10;                  &lt;div className=&quot;w-9 h-9 bg-gray-200 rounded-full&quot;&gt;&lt;/div&gt;&#13;&#10;                  &lt;div className=&quot;h-4 bg-gray-200 rounded w-20&quot;&gt;&lt;/div&gt;&#13;&#10;                &lt;/div&gt;&#13;&#10;                &lt;div className=&quot;h-4 bg-gray-200 rounded w-full&quot;&gt;&lt;/div&gt;&#13;&#10;              &lt;/div&gt;&#13;&#10;            ))}&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/section&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  // 에러 발생 시 에러 메시지 표시&#13;&#10;  if (error) {&#13;&#10;    return (&#13;&#10;      &lt;section className=&quot;mt-12 text-[#353841] text-[17px]&quot; aria-label=&quot;댓글 섹션&quot;&gt;&#13;&#10;        &lt;h2 className=&quot;mt-7 text-lg font-semibold&quot;&gt;댓글&lt;/h2&gt;&#13;&#10;        &lt;div className=&quot;mt-4 text-center text-red-500&quot;&gt;&#13;&#10;          &lt;p&gt;댓글을 불러오는 중 오류가 발생했습니다.&lt;/p&gt;&#13;&#10;          &lt;p className=&quot;text-sm text-gray-500 mt-2&quot;&gt;{error.message}&lt;/p&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/section&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;section className=&quot;mt-12 text-[#353841] text-[17px] mx-4&quot; aria-label=&quot;댓글 섹션&quot;&gt;&#13;&#10;      {/* TanStack Query가 댓글 추가를 자동으로 처리하므로 onCommentSubmitted는 선택사항 */}&#13;&#10;      &lt;CommentForm postId={postId} /&gt;&#13;&#10;&#13;&#10;      {/* TanStack Query가 댓글 삭제를 자동으로 처리하므로 onCommentDeleted는 선택사항 */}&#13;&#10;      &lt;CommentList&#13;&#10;        comments={comments}&#13;&#10;        variant=&quot;post&quot;&#13;&#10;        postId={postId}&#13;&#10;      /&gt;&#13;&#10;    &lt;/section&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/features/posts/PostForm.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/features/posts/PostForm.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import type { ToastEditorHandle } from &quot;@/components/ToastEditor&quot;;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import {&#10;  Form,&#10;  FormControl,&#10;  FormField,&#10;  FormItem,&#10;  FormMessage&#10;} from &quot;@/components/ui/form&quot;;&#10;import { Input } from &quot;@/components/ui/input&quot;;&#10;import { zodResolver } from &quot;@hookform/resolvers/zod&quot;;&#10;import { Eye, EyeOff } from &quot;lucide-react&quot;;&#10;import dynamic from &quot;next/dynamic&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import React, { useEffect, useRef, useState } from &quot;react&quot;;&#10;import { useForm, type SubmitHandler } from &quot;react-hook-form&quot;;&#10;import { z } from &quot;zod&quot;;&#10;&#10;const ToastEditor = dynamic(() =&gt; import(&quot;@/components/ToastEditor&quot;), {&#10;  ssr: false,&#10;});&#10;&#10;// Zod 스키마 정의&#10;const formSchema = z.object({&#10;  title: z.string().min(1, { message: &quot;제목은 필수입니다.&quot; }).max(100, { message: &quot;제목은 100자 이내로 입력해주세요.&quot; }),&#10;});&#10;&#10;type FormValues = z.infer&lt;typeof formSchema&gt;;&#10;&#10;export interface PostFormData {&#10;  title: string;&#10;  content: string;&#10;  tags: string[];&#10;  commitMessage: string;&#10;}&#10;&#10;interface PostFormProps {&#10;  mode: 'create' | 'edit';&#10;  initialData?: {&#10;    title: string;&#10;    content: string;&#10;    tags: string[];&#10;  };&#10;  onSubmit: (data: PostFormData) =&gt; Promise&lt;void&gt;;&#10;  isLoading: boolean;&#10;}&#10;&#10;export default function PostForm({&#10;  mode,&#10;  initialData,&#10;  onSubmit,&#10;  isLoading&#10;}: PostFormProps) {&#10;  const editorRef = useRef&lt;ToastEditorHandle&gt;(null);&#10;&#10;  const form = useForm&lt;FormValues&gt;({&#10;    resolver: zodResolver(formSchema),&#10;    defaultValues: {&#10;      title: initialData?.title || &quot;&quot;,&#10;    },&#10;  });&#10;&#10;  const [tags, setTags] = useState&lt;string[]&gt;(initialData?.tags || []);&#10;  const [currentTag, setCurrentTag] = useState(&quot;&quot;);&#10;  const [uploadingDots, setUploadingDots] = useState(&quot;&quot;);&#10;  const [isPreviewVisible, setIsPreviewVisible] = useState(true);&#10;&#10;  // 수정 모드일 때 초기 데이터 설정&#10;  useEffect(() =&gt; {&#10;    if (mode === 'edit' &amp;&amp; initialData) {&#10;      form.reset({&#10;        title: initialData.title,&#10;      });&#10;      setTags(initialData.tags || []);&#10;    }&#10;  }, [initialData, mode, form]);&#10;&#10;  const handleSubmit: SubmitHandler&lt;FormValues&gt; = async (data) =&gt; {&#10;    const markdown = editorRef.current?.getMarkdown() || &quot;&quot;;&#10;&#10;    if (!markdown.trim()) {&#10;      alert(&quot;내용을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    try {&#10;      await onSubmit({&#10;        title: data.title,&#10;        content: markdown,&#10;        tags: tags,&#10;        commitMessage: mode === 'create'&#10;          ? `새 게시글: ${data.title}`&#10;          : `게시글 수정: ${data.title}`,&#10;      });&#10;    } catch (error) {&#10;      console.error(`게시글 ${mode === 'create' ? '작성' : '수정'} 중 오류:`, error);&#10;      alert(`게시글 ${mode === 'create' ? '작성' : '수정'}에 실패했습니다. 다시 시도해주세요.`);&#10;    }&#10;  };&#10;&#10;  const handleAddTag = () =&gt; {&#10;    const tagWithoutHash = currentTag.startsWith(&quot;#&quot;) ? currentTag.slice(1) : currentTag;&#10;    const trimmedTag = tagWithoutHash.trim();&#10;&#10;    if (trimmedTag !== &quot;&quot; &amp;&amp; tags.length &lt; 2) {&#10;      const capitalizedTag =&#10;        trimmedTag.charAt(0).toUpperCase() + trimmedTag.slice(1).toLowerCase();&#10;      const newTag = `${capitalizedTag}`;&#10;&#10;      if (!tags.includes(newTag)) {&#10;        setTags([...tags, newTag]);&#10;      }&#10;    }&#10;    if (tags.length &lt; 2) {&#10;      setCurrentTag(&quot;&quot;);&#10;    }&#10;  };&#10;&#10;  const handleRemoveTag = (tagToRemove: string) =&gt; {&#10;    setTags(tags.filter((tag) =&gt; tag !== tagToRemove));&#10;  };&#10;&#10;  const handleTagInputChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;    setCurrentTag(e.target.value);&#10;  };&#10;&#10;  const handleTagInputKeyDown = (e: React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;    if (e.key === &quot;Enter&quot;) {&#10;      e.preventDefault();&#10;      handleAddTag();&#10;    }&#10;  };&#10;&#10;  const togglePreview = () =&gt; {&#10;    editorRef.current?.togglePreview();&#10;    setIsPreviewVisible(!isPreviewVisible);&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    let interval: NodeJS.Timeout;&#10;    if (isLoading) {&#10;      interval = setInterval(() =&gt; {&#10;        setUploadingDots((prevDots) =&gt; {&#10;          if (prevDots.length &gt;= 3) return &quot;.&quot;;&#10;          return prevDots + &quot;.&quot;;&#10;        });&#10;      }, 500);&#10;    } else {&#10;      setUploadingDots(&quot;&quot;);&#10;    }&#10;    return () =&gt; clearInterval(interval);&#10;  }, [isLoading]);&#10;&#10;  const buttonText = isLoading&#10;    ? `게시글 ${mode === 'create' ? '업로드' : '수정'} 중${uploadingDots}`&#10;    : mode === 'create' ? &quot;완료&quot; : &quot;수정 완료&quot;;&#10;&#10;  return (&#10;    &lt;Form {...form}&gt;&#10;      &lt;form onSubmit={form.handleSubmit(handleSubmit)} className=&quot;my-10 flex flex-col gap-6&quot;&gt;&#10;        &lt;FormField&#10;          control={form.control}&#10;          name=&quot;title&quot;&#10;          render={({ field }) =&gt; (&#10;            &lt;FormItem&gt;&#10;              &lt;FormControl&gt;&#10;                &lt;Input&#10;                  {...field}&#10;                  placeholder=&quot;제목을 입력해주세요.&quot;&#10;                  className=&quot;w-full h-11 focus:outline-none text-3xl border-0 focus-visible:ring-0 focus-visible:ring-offset-0 px-4 shadow-none&quot;&#10;                /&gt;&#10;              &lt;/FormControl&gt;&#10;              &lt;FormMessage /&gt;&#10;            &lt;/FormItem&gt;&#10;          )}&#10;        /&gt;&#10;&#10;        {/* 미리보기 토글 버튼 */}&#10;        &lt;div className=&quot;flex justify-end items-center&quot;&gt;&#10;          &lt;Button&#10;            type=&quot;button&quot;&#10;            variant=&quot;outline&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={togglePreview}&#10;            className=&quot;flex items-center gap-2 text-gray-600 hover:text-gray-800&quot;&#10;          &gt;&#10;            {isPreviewVisible ? (&#10;              &lt;&gt;&#10;                &lt;EyeOff size={16} /&gt;&#10;                &lt;span&gt;미리보기 숨기기&lt;/span&gt;&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;&gt;&#10;                &lt;Eye size={16} /&gt;&#10;                &lt;span&gt;미리보기 보기&lt;/span&gt;&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;ToastEditor&#10;          ref={editorRef}&#10;          initialValue={mode === 'edit' ? initialData?.content : undefined}&#10;        /&gt;&#10;&#10;        &lt;div className=&quot;flex flex-wrap gap-2 text-[14px]&quot;&gt;&#10;          {tags.map((tag, idx) =&gt; (&#10;            &lt;div&#10;              key={idx}&#10;              className=&quot;flex items-center gap-1 w-fit rounded-2xl bg-[#F2F4F6] px-2 py-1.5 text-[#848484]&quot;&#10;            &gt;&#10;              &lt;span&gt;# {tag}&lt;/span&gt;&#10;              &lt;Image&#10;                src=&quot;/tagDeleteBtn.svg&quot;&#10;                alt=&quot;태그 삭제 버튼&quot;&#10;                className=&quot;cursor-pointer hover:opacity-70&quot;&#10;                width={10}&#10;                height={10}&#10;                onClick={() =&gt; handleRemoveTag(tag)}&#10;              /&gt;&#10;            &lt;/div&gt;&#10;          ))}&#10;          &lt;Input&#10;            type=&quot;text&quot;&#10;            placeholder=&quot;태그 입력 후 Enter (최대 2개)&quot;&#10;            value={currentTag}&#10;            onChange={handleTagInputChange}&#10;            onKeyDown={handleTagInputKeyDown}&#10;            disabled={tags.length &gt;= 2}&#10;            className=&quot;h-auto p-1.5 border-0 focus-visible:ring-0 focus-visible:ring-offset-0 shadow-none bg-transparent w-auto flex-grow&quot;&#10;          /&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;Button&#10;          type=&quot;submit&quot;&#10;          className={`self-end px-6 py-2 bg-[#20242B] text-white rounded-4xl transition-colors duration-150 ${isLoading ? &quot;cursor-not-allowed opacity-70&quot; : &quot;hover:bg-[#33373E]/90 hover:cursor-pointer&quot;&#10;            }`}&#10;          disabled={isLoading}&#10;        &gt;&#10;          {buttonText}&#10;        &lt;/Button&gt;&#10;      &lt;/form&gt;&#10;    &lt;/Form&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import type { ToastEditorHandle } from &quot;@/components/ToastEditor&quot;;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import {&#10;  Form,&#10;  FormControl,&#10;  FormField,&#10;  FormItem,&#10;  FormMessage&#10;} from &quot;@/components/ui/form&quot;;&#10;import { Input } from &quot;@/components/ui/input&quot;;&#10;import { zodResolver } from &quot;@hookform/resolvers/zod&quot;;&#10;import { Eye, EyeOff } from &quot;lucide-react&quot;;&#10;import dynamic from &quot;next/dynamic&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import React, { useEffect, useRef, useState } from &quot;react&quot;;&#10;import { useForm, type SubmitHandler } from &quot;react-hook-form&quot;;&#10;import { z } from &quot;zod&quot;;&#10;&#10;const ToastEditor = dynamic(() =&gt; import(&quot;@/components/ToastEditor&quot;), {&#10;  ssr: false,&#10;});&#10;&#10;// Zod 스키마 정의&#10;const formSchema = z.object({&#10;  title: z.string().min(1, { message: &quot;제목은 필수입니다.&quot; }).max(100, { message: &quot;제목은 100자 이내로 입력해주세요.&quot; }),&#10;});&#10;&#10;type FormValues = z.infer&lt;typeof formSchema&gt;;&#10;&#10;export interface PostFormData {&#10;  title: string;&#10;  content: string;&#10;  tags: string[];&#10;  commitMessage: string;&#10;}&#10;&#10;interface PostFormProps {&#10;  mode: 'create' | 'edit';&#10;  initialData?: {&#10;    title: string;&#10;    content: string;&#10;    tags: string[];&#10;  };&#10;  onSubmitAction: (data: PostFormData) =&gt; Promise&lt;void&gt;;&#10;  isLoading: boolean;&#10;}&#10;&#10;export default function PostForm({&#10;  mode,&#10;  initialData,&#10;  onSubmitAction,&#10;  isLoading&#10;}: PostFormProps) {&#10;  const editorRef = useRef&lt;ToastEditorHandle&gt;(null);&#10;&#10;  const form = useForm&lt;FormValues&gt;({&#10;    resolver: zodResolver(formSchema),&#10;    defaultValues: {&#10;      title: initialData?.title || &quot;&quot;,&#10;    },&#10;  });&#10;&#10;  const [tags, setTags] = useState&lt;string[]&gt;(initialData?.tags || []);&#10;  const [currentTag, setCurrentTag] = useState(&quot;&quot;);&#10;  const [uploadingDots, setUploadingDots] = useState(&quot;&quot;);&#10;  const [isPreviewVisible, setIsPreviewVisible] = useState(true);&#10;&#10;  // 수정 모드일 때 초기 데이터 설정&#10;  useEffect(() =&gt; {&#10;    if (mode === 'edit' &amp;&amp; initialData) {&#10;      form.reset({&#10;        title: initialData.title,&#10;      });&#10;      setTags(initialData.tags || []);&#10;    }&#10;  }, [initialData, mode, form]);&#10;&#10;  const handleSubmit: SubmitHandler&lt;FormValues&gt; = async (data) =&gt; {&#10;    const markdown = editorRef.current?.getMarkdown() || &quot;&quot;;&#10;&#10;    if (!markdown.trim()) {&#10;      alert(&quot;내용을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    try {&#10;      await onSubmitAction({&#10;        title: data.title,&#10;        content: markdown,&#10;        tags: tags,&#10;        commitMessage: mode === 'create'&#10;          ? `새 게시글: ${data.title}`&#10;          : `게시글 수정: ${data.title}`,&#10;      });&#10;    } catch (error) {&#10;      console.error(`게시글 ${mode === 'create' ? '작성' : '수정'} 중 오류:`, error);&#10;      alert(`게시글 ${mode === 'create' ? '작성' : '수정'}에 실패했습니다. 다시 시도해주세요.`);&#10;    }&#10;  };&#10;&#10;  const handleAddTag = () =&gt; {&#10;    const tagWithoutHash = currentTag.startsWith(&quot;#&quot;) ? currentTag.slice(1) : currentTag;&#10;    const trimmedTag = tagWithoutHash.trim();&#10;&#10;    if (trimmedTag !== &quot;&quot; &amp;&amp; tags.length &lt; 2) {&#10;      const capitalizedTag =&#10;        trimmedTag.charAt(0).toUpperCase() + trimmedTag.slice(1).toLowerCase();&#10;      const newTag = `${capitalizedTag}`;&#10;&#10;      if (!tags.includes(newTag)) {&#10;        setTags([...tags, newTag]);&#10;      }&#10;    }&#10;    if (tags.length &lt; 2) {&#10;      setCurrentTag(&quot;&quot;);&#10;    }&#10;  };&#10;&#10;  const handleRemoveTag = (tagToRemove: string) =&gt; {&#10;    setTags(tags.filter((tag) =&gt; tag !== tagToRemove));&#10;  };&#10;&#10;  const handleTagInputChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;    setCurrentTag(e.target.value);&#10;  };&#10;&#10;  const handleTagInputKeyDown = (e: React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {&#10;    if (e.key === &quot;Enter&quot;) {&#10;      e.preventDefault();&#10;      handleAddTag();&#10;    }&#10;  };&#10;&#10;  const togglePreview = () =&gt; {&#10;    editorRef.current?.togglePreview();&#10;    setIsPreviewVisible(!isPreviewVisible);&#10;  };&#10;&#10;  useEffect(() =&gt; {&#10;    let interval: NodeJS.Timeout;&#10;    if (isLoading) {&#10;      interval = setInterval(() =&gt; {&#10;        setUploadingDots((prevDots) =&gt; {&#10;          if (prevDots.length &gt;= 3) return &quot;.&quot;;&#10;          return prevDots + &quot;.&quot;;&#10;        });&#10;      }, 500);&#10;    } else {&#10;      setUploadingDots(&quot;&quot;);&#10;    }&#10;    return () =&gt; clearInterval(interval);&#10;  }, [isLoading]);&#10;&#10;  const buttonText = isLoading&#10;    ? `게시글 ${mode === 'create' ? '업로드' : '수정'} 중${uploadingDots}`&#10;    : mode === 'create' ? &quot;완료&quot; : &quot;수정 완료&quot;;&#10;&#10;  return (&#10;    &lt;Form {...form}&gt;&#10;      &lt;form onSubmit={form.handleSubmit(handleSubmit)} className=&quot;my-10 flex flex-col gap-6&quot;&gt;&#10;        &lt;FormField&#10;          control={form.control}&#10;          name=&quot;title&quot;&#10;          render={({ field }) =&gt; (&#10;            &lt;FormItem&gt;&#10;              &lt;FormControl&gt;&#10;                &lt;Input&#10;                  {...field}&#10;                  placeholder=&quot;제목을 입력해주세요.&quot;&#10;                  className=&quot;w-full h-11 focus:outline-none text-3xl border-0 focus-visible:ring-0 focus-visible:ring-offset-0 px-4 shadow-none&quot;&#10;                /&gt;&#10;              &lt;/FormControl&gt;&#10;              &lt;FormMessage /&gt;&#10;            &lt;/FormItem&gt;&#10;          )}&#10;        /&gt;&#10;&#10;        {/* 미리보기 토글 버튼 */}&#10;        &lt;div className=&quot;flex justify-end items-center&quot;&gt;&#10;          &lt;Button&#10;            type=&quot;button&quot;&#10;            variant=&quot;outline&quot;&#10;            size=&quot;sm&quot;&#10;            onClick={togglePreview}&#10;            className=&quot;flex items-center gap-2 text-gray-600 hover:text-gray-800&quot;&#10;          &gt;&#10;            {isPreviewVisible ? (&#10;              &lt;&gt;&#10;                &lt;EyeOff size={16} /&gt;&#10;                &lt;span&gt;미리보기 숨기기&lt;/span&gt;&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;&gt;&#10;                &lt;Eye size={16} /&gt;&#10;                &lt;span&gt;미리보기 보기&lt;/span&gt;&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;ToastEditor&#10;          ref={editorRef}&#10;          initialValue={mode === 'edit' ? initialData?.content : undefined}&#10;        /&gt;&#10;&#10;        &lt;div className=&quot;flex flex-wrap gap-2 text-[14px]&quot;&gt;&#10;          {tags.map((tag, idx) =&gt; (&#10;            &lt;div&#10;              key={idx}&#10;              className=&quot;flex items-center gap-1 w-fit rounded-2xl bg-[#F2F4F6] px-2 py-1.5 text-[#848484]&quot;&#10;            &gt;&#10;              &lt;span&gt;# {tag}&lt;/span&gt;&#10;              &lt;Image&#10;                src=&quot;/tagDeleteBtn.svg&quot;&#10;                alt=&quot;태그 삭제 버튼&quot;&#10;                className=&quot;cursor-pointer hover:opacity-70&quot;&#10;                width={10}&#10;                height={10}&#10;                onClick={() =&gt; handleRemoveTag(tag)}&#10;              /&gt;&#10;            &lt;/div&gt;&#10;          ))}&#10;          &lt;Input&#10;            type=&quot;text&quot;&#10;            placeholder=&quot;태그 입력 후 Enter (최대 2개)&quot;&#10;            value={currentTag}&#10;            onChange={handleTagInputChange}&#10;            onKeyDown={handleTagInputKeyDown}&#10;            disabled={tags.length &gt;= 2}&#10;            className=&quot;h-auto p-1.5 border-0 focus-visible:ring-0 focus-visible:ring-offset-0 shadow-none bg-transparent w-auto flex-grow&quot;&#10;          /&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;Button&#10;          type=&quot;submit&quot;&#10;          className={`self-end px-6 py-2 bg-[#20242B] text-white rounded-4xl transition-colors duration-150 ${isLoading ? &quot;cursor-not-allowed opacity-70&quot; : &quot;hover:bg-[#33373E]/90 hover:cursor-pointer&quot;&#10;            }`}&#10;          disabled={isLoading}&#10;        &gt;&#10;          {buttonText}&#10;        &lt;/Button&gt;&#10;      &lt;/form&gt;&#10;    &lt;/Form&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/features/posts/PostHeader.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/features/posts/PostHeader.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { PostActionsDropdown } from &quot;@/components/features/posts/PostActionsDropdown&quot;;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import TagBadge from '@/components/ui/TagBadge';&#10;import { useAuth } from &quot;@/hooks/queries/useUserQueries&quot;;&#10;import { cn } from &quot;@/lib/utils&quot;;&#10;import { PostDetailData } from &quot;@/types/comment&quot;;&#10;import Image from 'next/image';&#10;&#10;interface PostHeaderProps {&#10;  post: PostDetailData;&#10;  postId: number;&#10;}&#10;&#10;export default function PostHeader({ post, postId }: PostHeaderProps) {&#10;  const { userProfile, isLoggedIn } = useAuth();&#10;&#10;  // 현재 로그인한 사용자가 게시글 작성자인지 확인&#10;  const isCurrentUserAuthor = isLoggedIn &amp;&amp; userProfile &amp;&amp; userProfile.nickname === post.writer;&#10;&#10;  const headerTriggerElement = (&#10;    &lt;Button&#10;      variant=&quot;ghost&quot;&#10;      className={cn(&quot;relative h-8 w-8 rounded-full p-0 focus-visible:ring-0 focus-visible:ring-offset-0 hover:cursor-pointer ml-auto&quot;)}&#10;    &gt;&#10;      &lt;Image&#10;        src=&quot;/dot3.svg&quot;&#10;        alt=&quot;더보기&quot;&#10;        width={18}&#10;        height={4}&#10;      /&gt;&#10;    &lt;/Button&gt;&#10;  );&#10;&#10;  return (&#10;    &lt;header&gt;&#10;      &lt;h1 className=&quot;text-[32px] font-extrabold text-[#1C222E]&quot;&gt;&#10;        {post.title}&#10;      &lt;/h1&gt;&#10;&#10;      &lt;div className=&quot;flex h-12 items-center gap-4 text-[14px]&quot;&gt;&#10;        &lt;div className=&quot;flex h-5 items-center border-r border-[#B5BBC7] pr-3&quot;&gt;&#10;          {post.writerProfileImageUrl ? (&#10;            &lt;Image&#10;              src={post.writerProfileImageUrl}&#10;              alt={`${post.writer}의 프로필 이미지`}&#10;              width={24}&#10;              height={24}&#10;              className=&quot;rounded-full&quot;&#10;              priority={true}&#10;              unoptimized={post.writerProfileImageUrl.includes('amazonaws.com')}&#10;            /&gt;&#10;          ) : (&#10;            &lt;div className=&quot;w-6 h-6 bg-gray-300 rounded-full flex items-center justify-center&quot;&gt;&#10;              &lt;span className=&quot;text-xs text-gray-600&quot;&gt;&#10;                {post.writer?.[0]?.toUpperCase() || '?'}&#10;              &lt;/span&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;          &lt;span className=&quot;ml-2 font-medium text-[#798191]&quot;&gt;&#10;            {post.writer}&#10;          &lt;/span&gt;&#10;        &lt;/div&gt;&#10;        &lt;time dateTime={new Date(post.createdAt).toISOString().split(&quot;T&quot;)[0]} className=&quot;text-[#B5BBC7]&quot;&gt;&#10;          {new Date(post.createdAt).toLocaleDateString('ko-KR')}&#10;        &lt;/time&gt;&#10;&#10;        {/* 게시글 작성자인 경우에만 액션 드롭다운 표시 */}&#10;        {isCurrentUserAuthor &amp;&amp; (&#10;          &lt;PostActionsDropdown&#10;            postId={postId}&#10;            triggerElement={headerTriggerElement}&#10;          /&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      &lt;ul className=&quot;flex gap-2 text-[14px]&quot; role=&quot;list&quot;&gt;&#10;        {post.tags.map((tag, index) =&gt; (&#10;          &lt;li key={index}&gt;&#10;            &lt;TagBadge tag={tag} variant=&quot;gray&quot; /&gt;&#10;          &lt;/li&gt;&#10;        ))}&#10;      &lt;/ul&gt;&#10;    &lt;/header&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { PostActionsDropdown } from &quot;@/components/features/posts/PostActionsDropdown&quot;;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import TagBadge from '@/components/ui/TagBadge';&#10;import { useAuth } from &quot;@/hooks/queries/useUserQueries&quot;;&#10;import { cn } from &quot;@/lib/utils&quot;;&#10;import { PostDetailResponse } from &quot;@/generated/api&quot;;&#10;import Image from 'next/image';&#10;&#10;interface PostHeaderProps {&#10;  post: PostDetailResponse;&#10;  postId: number;&#10;}&#10;&#10;export default function PostHeader({ post, postId }: PostHeaderProps) {&#10;  const { userProfile, isLoggedIn } = useAuth();&#10;&#10;  // 현재 로그인한 사용자가 게시글 작성자인지 확인&#10;  const isCurrentUserAuthor = isLoggedIn &amp;&amp; userProfile &amp;&amp; userProfile.nickname === post.writer;&#10;&#10;  const headerTriggerElement = (&#10;    &lt;Button&#10;      variant=&quot;ghost&quot;&#10;      className={cn(&quot;relative h-8 w-8 rounded-full p-0 focus-visible:ring-0 focus-visible:ring-offset-0 hover:cursor-pointer ml-auto&quot;)}&#10;    &gt;&#10;      &lt;Image&#10;        src=&quot;/dot3.svg&quot;&#10;        alt=&quot;더보기&quot;&#10;        width={18}&#10;        height={4}&#10;      /&gt;&#10;    &lt;/Button&gt;&#10;  );&#10;&#10;  return (&#10;    &lt;header&gt;&#10;      &lt;h1 className=&quot;text-[32px] font-extrabold text-[#1C222E]&quot;&gt;&#10;        {post.title}&#10;      &lt;/h1&gt;&#10;&#10;      &lt;div className=&quot;flex h-12 items-center gap-4 text-[14px]&quot;&gt;&#10;        &lt;div className=&quot;flex h-5 items-center border-r border-[#B5BBC7] pr-3&quot;&gt;&#10;          {post.writerProfileImageUrl ? (&#10;            &lt;Image&#10;              src={post.writerProfileImageUrl}&#10;              alt={`${post.writer}의 프로필 이미지`}&#10;              width={24}&#10;              height={24}&#10;              className=&quot;rounded-full&quot;&#10;              priority={true}&#10;              unoptimized={post.writerProfileImageUrl.includes('amazonaws.com')}&#10;            /&gt;&#10;          ) : (&#10;            &lt;div className=&quot;w-6 h-6 bg-gray-300 rounded-full flex items-center justify-center&quot;&gt;&#10;              &lt;span className=&quot;text-xs text-gray-600&quot;&gt;&#10;                {post.writer?.[0]?.toUpperCase() || '?'}&#10;              &lt;/span&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;          &lt;span className=&quot;ml-2 font-medium text-[#798191]&quot;&gt;&#10;            {post.writer}&#10;          &lt;/span&gt;&#10;        &lt;/div&gt;&#10;        &lt;time dateTime={post.createdAt ? new Date(post.createdAt).toISOString().split(&quot;T&quot;)[0] : undefined} className=&quot;text-[#B5BBC7]&quot;&gt;&#10;          {post.createdAt ? new Date(post.createdAt).toLocaleDateString('ko-KR') : '날짜 없음'}&#10;        &lt;/time&gt;&#10;&#10;        {/* 게시글 작성자인 경우에만 액션 드롭다운 표시 */}&#10;        {isCurrentUserAuthor &amp;&amp; (&#10;          &lt;PostActionsDropdown&#10;            postId={postId}&#10;            triggerElement={headerTriggerElement}&#10;          /&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      &lt;ul className=&quot;flex gap-2 text-[14px]&quot; role=&quot;list&quot;&gt;&#10;        {post.tags?.map((tag, index) =&gt; (&#10;          &lt;li key={index}&gt;&#10;            &lt;TagBadge tag={tag} variant=&quot;gray&quot; /&gt;&#10;          &lt;/li&gt;&#10;        ))}&#10;      &lt;/ul&gt;&#10;    &lt;/header&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/mypage/tabs/CommentsTab.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/mypage/tabs/CommentsTab.tsx" />
              <option name="originalContent" value="/**&#10; * 마이페이지 댓글 탭 컴포넌트&#10; * &#10; * 사용자가 작성한 댓글 목록을 표시하며,&#10; * 로딩, 에러, 빈 상태를 독립적으로 관리합니다.&#10; */&#10;&#10;import CommentList from &quot;@/components/features/comments/CommentList&quot;;&#10;import ErrorDisplay from &quot;@/components/mypage/shared/ErrorDisplay&quot;;&#10;import { Skeleton } from &quot;@/components/ui/skeleton&quot;;&#10;import { useMyComments } from &quot;@/hooks/queries/useMyPageQueries&quot;;&#10;import { usePagination } from &quot;@/hooks/usePagination&quot;;&#10;import CustomPagination from &quot;../../common/CustomPagination&quot;;&#10;&#10;export default function CommentsTab() {&#10;  const { currentPage, currentPageForAPI, setPage } = usePagination();&#10;  const pageSize = 5;&#10;&#10;  console.log(&quot;CommentsTab render - currentPage:&quot;, currentPage, &quot;API page:&quot;, currentPageForAPI);&#10;&#10;  const { data: commentsData, isLoading, error } = useMyComments({&#10;    page: currentPageForAPI,&#10;    size: pageSize,&#10;    sort: [&quot;createdAt,desc&quot;], // 최신순 정렬&#10;  });&#10;&#10;  console.log(&quot;CommentsTab - commentsData:&quot;, commentsData);&#10;&#10;  const totalPages = commentsData?.totalPages || 0;&#10;  const totalElements = commentsData?.totalElements || 0;&#10;&#10;  const handlePageChange = (page: number) =&gt; {&#10;    console.log(&quot;Page change requested:&quot;, page, &quot;Current page:&quot;, currentPage);&#10;    setPage(page); // usePagination 훅의 setPage 사용 (1부터 시작하는 페이지)&#10;    console.log(&quot;New currentPage will be:&quot;, page);&#10;  };&#10;&#10;&#10;  // 로딩 상태&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;flex flex-col gap-4 mt-8&quot;&gt;&#10;        {/* 댓글 로딩 스켈레톤 */}&#10;        {[...Array(3)].map((_, index) =&gt; (&#10;          &lt;div key={index} className=&quot;bg-gray-100 rounded-xl px-6 py-5 space-y-2&quot;&gt;&#10;            &lt;Skeleton className=&quot;h-4 w-1/4&quot; /&gt;&#10;            &lt;Skeleton className=&quot;h-4 w-full&quot; /&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;  // 에러 상태&#10;  if (error) {&#10;    return (&#10;      &lt;ErrorDisplay&#10;        title=&quot;댓글을 불러올 수 없습니다&quot;&#10;        error={error}&#10;      /&gt;&#10;    );&#10;  }&#10;  // 데이터 표시&#10;  if (!commentsData || commentsData.content.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center mt-12&quot;&gt;&#10;        &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;          &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; viewBox=&quot;0 0 24 24&quot;&gt;&#10;            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={1} d=&quot;M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z&quot; /&gt;&#10;          &lt;/svg&gt;&#10;        &lt;/div&gt;&#10;        &lt;p className=&quot;text-gray-500 text-lg mb-2&quot;&gt;작성한 댓글이 없습니다&lt;/p&gt;&#10;        &lt;p className=&quot;text-gray-400 text-sm&quot;&gt;다른 사용자의 게시글에 댓글을 달아보세요!&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;  // 새로운 통합 CommentList 사용 - variant='my'로 내 댓글 모드&#10;  return (&#10;    &lt;&gt;&#10;      &lt;CommentList&#10;        comments={commentsData.content}&#10;        variant=&quot;my&quot;&#10;        className=&quot;mt-6&quot;&#10;      /&gt;      {/* 페이지네이션이 표시되는지 확인을 위한 로그 */}&#10;      {console.log(&quot;Pagination render check - totalPages:&quot;, totalPages, &quot;currentPage:&quot;, currentPage)}&#10;      {totalPages &gt; 1 &amp;&amp; (&#10;        &lt;CustomPagination&#10;          currentPage={currentPage} // 이미 1부터 시작하는 값&#10;          totalPages={totalPages}&#10;          onPageChange={handlePageChange}&#10;          className=&quot;mt-12&quot;&#10;        /&gt;&#10;      )}&#10;    &lt;/&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * 마이페이지 댓글 탭 컴포넌트&#10; * &#10; * 사용자가 작성한 댓글 목록을 표시하며,&#10; * 로딩, 에러, 빈 상태를 독립적으로 관리합니다.&#10; */&#10;&#10;import CommentList from &quot;@/components/features/comments/CommentList&quot;;&#10;import ErrorDisplay from &quot;@/components/mypage/shared/ErrorDisplay&quot;;&#10;import { Skeleton } from &quot;@/components/ui/skeleton&quot;;&#10;import { useMyComments } from &quot;@/hooks/queries/useMyPageQueries&quot;;&#10;import { usePagination } from &quot;@/hooks/usePagination&quot;;&#10;import CustomPagination from &quot;../../common/CustomPagination&quot;;&#10;&#10;export default function CommentsTab() {&#10;  const { currentPage, currentPageForAPI, setPage } = usePagination();&#10;  const pageSize = 5;&#10;&#10;  console.log(&quot;CommentsTab render - currentPage:&quot;, currentPage, &quot;API page:&quot;, currentPageForAPI);&#10;&#10;  const { data: commentsData, isLoading, error } = useMyComments({&#10;    page: currentPageForAPI,&#10;    size: pageSize,&#10;    sort: [&quot;createdAt,desc&quot;], // 최신순 정렬&#10;  });&#10;&#10;  console.log(&quot;CommentsTab - commentsData:&quot;, commentsData);&#10;&#10;  const totalPages = commentsData?.totalPages || 0;&#10;&#10;  const handlePageChange = (page: number) =&gt; {&#10;    console.log(&quot;Page change requested:&quot;, page, &quot;Current page:&quot;, currentPage);&#10;    setPage(page); // usePagination 훅의 setPage 사용 (1부터 시작하는 페이지)&#10;    console.log(&quot;New currentPage will be:&quot;, page);&#10;  };&#10;&#10;  // 로딩 상태&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;flex flex-col gap-4 mt-8&quot;&gt;&#10;        {/* 댓글 로딩 스켈레톤 */}&#10;        {[...Array(3)].map((_, index) =&gt; (&#10;          &lt;div key={index} className=&quot;bg-gray-100 rounded-xl px-6 py-5 space-y-2&quot;&gt;&#10;            &lt;Skeleton className=&quot;h-4 w-1/4&quot; /&gt;&#10;            &lt;Skeleton className=&quot;h-4 w-full&quot; /&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;  // 에러 상태&#10;  if (error) {&#10;    return (&#10;      &lt;ErrorDisplay&#10;        title=&quot;댓글을 불러올 수 없습니다&quot;&#10;        error={error}&#10;      /&gt;&#10;    );&#10;  }&#10;  // 데이터 표시&#10;  if (!commentsData || !commentsData.content || commentsData.content.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center mt-12&quot;&gt;&#10;        &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;          &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; viewBox=&quot;0 0 24 24&quot;&gt;&#10;            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={1} d=&quot;M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z&quot; /&gt;&#10;          &lt;/svg&gt;&#10;        &lt;/div&gt;&#10;        &lt;p className=&quot;text-gray-500 text-lg mb-2&quot;&gt;작성한 댓글이 없습니다&lt;/p&gt;&#10;        &lt;p className=&quot;text-gray-400 text-sm&quot;&gt;다른 사용자의 게시글에 댓글을 달아보세요!&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 새로운 통합 CommentList 사용 - variant='my'로 내 댓글 모드&#10;  return (&#10;    &lt;&gt;&#10;      &lt;CommentList&#10;        comments={commentsData.content as any[]} // PagedResponse의 content는 object[]이므로 타입 단언 사용&#10;        variant=&quot;my&quot;&#10;        className=&quot;mt-6&quot;&#10;      /&gt;&#10;      {/* 페이지네이션 */}&#10;      {totalPages &gt; 1 &amp;&amp; (&#10;        &lt;CustomPagination&#10;          currentPage={currentPage} // 이미 1부터 시작하는 값&#10;          totalPages={totalPages}&#10;          onPageChange={handlePageChange}&#10;          className=&quot;mt-12&quot;&#10;        /&gt;&#10;      )}&#10;    &lt;/&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/mypage/tabs/PostsTab.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/mypage/tabs/PostsTab.tsx" />
              <option name="originalContent" value="/**&#10; * 마이페이지 게시글 탭 컴포넌트&#10; * &#10; * 사용자가 작성한 게시글 목록을 표시하며,&#10; * 로딩, 에러, 빈 상태를 독립적으로 관리합니다.&#10; */&#10;&#10;import CustomPagination from &quot;@/components/common/CustomPagination&quot;;&#10;import PostCard from &quot;@/components/features/posts/PostCard&quot;;&#10;import ErrorDisplay from &quot;@/components/mypage/shared/ErrorDisplay&quot;;&#10;import { Skeleton } from &quot;@/components/ui/skeleton&quot;;&#10;import { useMyPosts } from &quot;@/hooks/queries/useMyPageQueries&quot;;&#10;import { usePagination } from &quot;@/hooks/usePagination&quot;;&#10;&#10;export default function PostsTab() {&#10;  const { currentPage, currentPageForAPI, setPage } = usePagination();&#10;  const pageSize = 5;&#10;&#10;  const { data: postsData, isLoading, error } = useMyPosts({&#10;    page: currentPageForAPI,&#10;    size: pageSize,&#10;    sort: [&quot;createdAt,desc&quot;], // 최신순 정렬&#10;  });&#10;&#10;  const posts = postsData?.content || [];&#10;  const totalPages = postsData?.totalPages || 0;&#10;  const totalElements = postsData?.totalElements || 0;&#10;&#10;  const handlePageChange = (page: number) =&gt; {&#10;    setPage(page); // usePagination 훅의 setPage 사용&#10;  };&#10;&#10;  // 로딩 상태&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;flex flex-col gap-8 mt-8&quot;&gt;&#10;        {/* 게시글 로딩 스켈레톤 */}&#10;        {[...Array(3)].map((_, index) =&gt; (&#10;          &lt;div key={index} className=&quot;space-y-3&quot;&gt;&#10;            &lt;Skeleton className=&quot;h-6 w-3/4&quot; /&gt;&#10;            &lt;Skeleton className=&quot;h-4 w-1/2&quot; /&gt;&#10;            &lt;Skeleton className=&quot;h-4 w-full&quot; /&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;  // 에러 상태&#10;  if (error) {&#10;    return (&#10;      &lt;ErrorDisplay&#10;        title=&quot;게시글을 불러올 수 없습니다&quot;&#10;        error={error}&#10;      /&gt;&#10;    );&#10;  }&#10;  // 빈 상태&#10;  if (posts.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center mt-12&quot;&gt;&#10;        &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;          &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; viewBox=&quot;0 0 24 24&quot;&gt;&#10;            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={1} d=&quot;M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z&quot; /&gt;&#10;          &lt;/svg&gt;&#10;        &lt;/div&gt;&#10;        &lt;p className=&quot;text-gray-500 text-lg mb-2&quot;&gt;작성한 게시글이 없습니다&lt;/p&gt;&#10;        &lt;p className=&quot;text-gray-400 text-sm&quot;&gt;첫 번째 게시글을 작성해보세요!&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 게시글 목록 표시&#10;  return (&#10;    &lt;div className=&quot;flex flex-col gap-8 mt-8&quot;&gt;&#10;      {posts.map((post) =&gt; (&#10;        &lt;PostCard&#10;          key={post.postId}&#10;          post={post}&#10;        /&gt;&#10;      ))}&#10;      &lt;CustomPagination&#10;        currentPage={currentPage} // 이미 1부터 시작하는 값&#10;        totalPages={totalPages}&#10;        onPageChange={handlePageChange}&#10;        className=&quot;mt-12&quot;&#10;      /&gt;&#10;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * 마이페이지 게시글 탭 컴포넌트&#10; * &#10; * 사용자가 작성한 게시글 목록을 표시하며,&#10; * 로딩, 에러, 빈 상태를 독립적으로 관리합니다.&#10; */&#10;&#10;import CustomPagination from &quot;@/components/common/CustomPagination&quot;;&#10;import PostCard from &quot;@/components/features/posts/PostCard&quot;;&#10;import ErrorDisplay from &quot;@/components/mypage/shared/ErrorDisplay&quot;;&#10;import { Skeleton } from &quot;@/components/ui/skeleton&quot;;&#10;import { useMyPosts } from &quot;@/hooks/queries/useMyPageQueries&quot;;&#10;import { usePagination } from &quot;@/hooks/usePagination&quot;;&#10;&#10;export default function PostsTab() {&#10;  const { currentPage, currentPageForAPI, setPage } = usePagination();&#10;  const pageSize = 5;&#10;&#10;  const { data: postsData, isLoading, error } = useMyPosts({&#10;    page: currentPageForAPI,&#10;    size: pageSize,&#10;    sort: [&quot;createdAt,desc&quot;], // 최신순 정렬&#10;  });&#10;&#10;  const posts = postsData?.content || [];&#10;  const totalPages = postsData?.totalPages || 0;&#10;&#10;  const handlePageChange = (page: number) =&gt; {&#10;    setPage(page); // usePagination 훅의 setPage 사용&#10;  };&#10;&#10;  // 로딩 상태&#10;  if (isLoading) {&#10;    return (&#10;      &lt;div className=&quot;flex flex-col gap-8 mt-8&quot;&gt;&#10;        {/* 게시글 로딩 스켈레톤 */}&#10;        {[...Array(3)].map((_, index) =&gt; (&#10;          &lt;div key={index} className=&quot;space-y-3&quot;&gt;&#10;            &lt;Skeleton className=&quot;h-6 w-3/4&quot; /&gt;&#10;            &lt;Skeleton className=&quot;h-4 w-1/2&quot; /&gt;&#10;            &lt;Skeleton className=&quot;h-4 w-full&quot; /&gt;&#10;          &lt;/div&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;  // 에러 상태&#10;  if (error) {&#10;    return (&#10;      &lt;ErrorDisplay&#10;        title=&quot;게시글을 불러올 수 없습니다&quot;&#10;        error={error}&#10;      /&gt;&#10;    );&#10;  }&#10;  // 빈 상태&#10;  if (posts.length === 0) {&#10;    return (&#10;      &lt;div className=&quot;text-center mt-12&quot;&gt;&#10;        &lt;div className=&quot;text-gray-400 mb-4&quot;&gt;&#10;          &lt;svg className=&quot;w-16 h-16 mx-auto&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; viewBox=&quot;0 0 24 24&quot;&gt;&#10;            &lt;path strokeLinecap=&quot;round&quot; strokeLinejoin=&quot;round&quot; strokeWidth={1} d=&quot;M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z&quot; /&gt;&#10;          &lt;/svg&gt;&#10;        &lt;/div&gt;&#10;        &lt;p className=&quot;text-gray-500 text-lg mb-2&quot;&gt;작성한 게시글이 없습니다&lt;/p&gt;&#10;        &lt;p className=&quot;text-gray-400 text-sm&quot;&gt;첫 번째 게시글을 작성해보세요!&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 게시글 목록 표시&#10;  return (&#10;    &lt;div className=&quot;flex flex-col gap-8 mt-8&quot;&gt;&#10;      {posts.map((post, index) =&gt; (&#10;        &lt;PostCard&#10;          key={(post as any).postId || index}&#10;          post={post as any}&#10;        /&gt;&#10;      ))}&#10;      {totalPages &gt; 1 &amp;&amp; (&#10;        &lt;CustomPagination&#10;          currentPage={currentPage} // 이미 1부터 시작하는 값&#10;          totalPages={totalPages}&#10;          onPageChange={handlePageChange}&#10;          className=&quot;mt-12&quot;&#10;        /&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hooks/queries/useMyPageQueries.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hooks/queries/useMyPageQueries.ts" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 마이페이지 관련 TanStack Query 훅 모음&#10; * &#10; * 마이페이지에서 필요한 사용자의 게시글, 댓글, 좋아요 데이터를 &#10; * TanStack Query를 통해 효율적으로 관리합니다.&#10; */&#10;&#10;import { postService } from &quot;@/services/postService&quot;;&#10;import { PageableContent, PaginationParams } from &quot;@/types/api&quot;;&#10;import { useQuery, UseQueryOptions } from &quot;@tanstack/react-query&quot;;&#10;import { commentService } from &quot;@/services/commentService&quot;;&#10;import { PostResponse } from &quot;@/generated/api&quot;;&#10;&#10;/**&#10; * 사용자가 작성한 게시글 목록을 조회하는 훅&#10; * 인증이 필요한 사용자별 게시글 조회 기능입니다.&#10; * &#10; * @param params - 페이지네이션 및 정렬 파라미터&#10; * @param options - TanStack Query 옵션&#10; */&#10;export function useMyPosts(&#10;  params?: PaginationParams,&#10;  options?: Omit&lt;UseQueryOptions&lt;PageableContent&lt;PostResponse&gt;, Error&gt;, 'queryKey' | 'queryFn'&gt;&#10;) {&#10;  return useQuery({&#10;    queryKey: [&quot;my-posts&quot;, params], // 캐시 키: 사용자의 게시글 목록&#10;    queryFn: () =&gt; postService.getUserPosts(params),&#10;&#10;    staleTime: 1000 * 60 * 2, // 2분간 fresh 상태 유지 (사용자 데이터는 더 자주 갱신)&#10;    gcTime: 1000 * 60 * 10, // 10분간 캐시 유지&#10;    retry: 2,&#10;    refetchOnWindowFocus: false,&#10;    ...options,&#10;  });&#10;}&#10;&#10;/**&#10; * 사용자가 작성한 댓글 목록을 가져오는 훅&#10; * &#10; * 이 훅은 TanStack Query의 useQuery를 사용하여:&#10; * - 사용자의 댓글 목록을 자동 캐싱&#10; * - 백그라운드에서 자동 갱신&#10; * - 로딩/에러 상태 자동 관리&#10; * - 댓글 추가/삭제 시 자동 무효화 가능&#10; * &#10; * @returns {object} 쿼리 결과 객체 (data, isLoading, error 등)&#10; */&#10;export function useMyComments(&#10;  params?: PaginationParams,&#10;) {&#10;  return useQuery({&#10;    queryKey: [&quot;my-comments&quot;, params], // 캐시 키에 params 포함하여 페이지 변경 감지&#10;    queryFn: () =&gt; commentService.getUserComments(params),&#10;&#10;    staleTime: 1000 * 60 * 5, // 5분간 데이터를 신선하다고 간주&#10;    gcTime: 1000 * 60 * 10, // 10분간 캐시 유지&#10;  });&#10;}&#10;&#10;/**&#10; * 사용자가 좋아요한 게시글 목록을 가져오는 훅&#10; * &#10; * 이 훅은 TanStack Query의 useQuery를 사용하여:&#10; * - 사용자의 좋아요 목록을 자동 캐싱&#10; * - 백그라운드에서 자동 갱신  &#10; * - 로딩/에러 상태 자동 관리&#10; * - 좋아요 추가/취소 시 자동 무효화 가능&#10; * &#10; * @returns {object} 쿼리 결과 객체 (data, isLoading, error 등)&#10; */&#10;export function useMyLikes(params?: PaginationParams) {&#10;  return useQuery({&#10;    queryKey: [&quot;my-likes&quot;, params], // 캐시 키: 사용자의 좋아요 목록&#10;    queryFn: () =&gt; postService.getUserLikes(params),&#10;&#10;    staleTime: 1000 * 60 * 5, // 5분간 데이터를 신선하다고 간주&#10;    gcTime: 1000 * 60 * 10, // 10분간 캐시 유지&#10;  });&#10;}&#10;&#10;/**&#10; * 마이페이지 모든 데이터를 한 번에 가져오는 복합 훅&#10; * &#10; * 이 훅은 여러 쿼리를 병렬로 실행하여:&#10; * - 게시글, 댓글, 좋아요 데이터를 동시에 로드&#10; * - 각각의 로딩/에러 상태를 개별 관리&#10; * - 전체 로딩 상태와 각 섹션 상태를 모두 제공&#10; * &#10; * @returns {object} 모든 마이페이지 데이터와 상태&#10; */&#10;export function useMyPageData() {&#10;  const postsQuery = useMyPosts();&#10;  const commentsQuery = useMyComments();&#10;  const likesQuery = useMyLikes();&#10;&#10;  return {&#10;    // 각 섹션 데이터&#10;    posts: postsQuery.data || [],&#10;    comments: commentsQuery.data || [],&#10;    likes: likesQuery.data || [],&#10;&#10;    // 개별 로딩 상태&#10;    isLoadingPosts: postsQuery.isLoading,&#10;    isLoadingComments: commentsQuery.isLoading,&#10;    isLoadingLikes: likesQuery.isLoading,&#10;&#10;    // 전체 로딩 상태 (모든 쿼리가 로딩 중인지)&#10;    isLoading: postsQuery.isLoading || commentsQuery.isLoading || likesQuery.isLoading,&#10;&#10;    // 개별 에러 상태&#10;    postsError: postsQuery.error,&#10;    commentsError: commentsQuery.error,&#10;    likesError: likesQuery.error,&#10;&#10;    // 전체 에러 상태 (하나라도 에러가 있는지)&#10;    hasError: !!postsQuery.error || !!commentsQuery.error || !!likesQuery.error,&#10;&#10;    // 개별 쿼리 객체 (필요 시 직접 접근 가능)&#10;    postsQuery,&#10;    commentsQuery,&#10;    likesQuery,&#10;  };&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;/**&#10; * 마이페이지 관련 TanStack Query 훅 모음&#10; * &#10; * 마이페이지에서 필요한 사용자의 게시글, 댓글, 좋아요 데이터를 &#10; * TanStack Query를 통해 효율적으로 관리합니다.&#10; */&#10;&#10;import { postService } from &quot;@/services/postService&quot;;&#10;import { PagedResponse, Pageable, PostResponse } from &quot;@/generated/api&quot;;&#10;import { useQuery, UseQueryOptions } from &quot;@tanstack/react-query&quot;;&#10;import { commentService } from &quot;@/services/commentService&quot;;&#10;&#10;/**&#10; * 사용자가 작성한 게시글 목록을 조회하는 훅&#10; * 인증이 필요한 사용자별 게시글 조회 기능입니다.&#10; * &#10; * @param params - 페이지네이션 및 정렬 파라미터&#10; * @param options - TanStack Query 옵션&#10; */&#10;export function useMyPosts(&#10;  params?: Pageable,&#10;  options?: Omit&lt;UseQueryOptions&lt;PagedResponse, Error&gt;, 'queryKey' | 'queryFn'&gt;&#10;) {&#10;  return useQuery({&#10;    queryKey: [&quot;my-posts&quot;, params], // 캐시 키: 사용자의 게시글 목록&#10;    queryFn: () =&gt; postService.getUserPosts(params),&#10;&#10;    staleTime: 1000 * 60 * 2, // 2분간 fresh 상태 유지 (사용자 데이터는 더 자주 갱신)&#10;    gcTime: 1000 * 60 * 10, // 10분간 캐시 유지&#10;    retry: 2,&#10;    refetchOnWindowFocus: false,&#10;    ...options,&#10;  });&#10;}&#10;&#10;/**&#10; * 사용자가 작성한 댓글 목록을 가져오는 훅&#10; * &#10; * 이 훅은 TanStack Query의 useQuery를 사용하여:&#10; * - 사용자의 댓글 목록을 자동 캐싱&#10; * - 백그라운드에서 자동 갱신&#10; * - 로딩/에러 상태 자동 관리&#10; * - 댓글 추가/삭제 시 자동 무효화 가능&#10; * &#10; * @returns {object} 쿼리 결과 객체 (data, isLoading, error 등)&#10; */&#10;export function useMyComments(&#10;  params?: Pageable,&#10;) {&#10;  return useQuery({&#10;    queryKey: [&quot;my-comments&quot;, params], // 캐시 키에 params 포함하여 페이지 변경 감지&#10;    queryFn: () =&gt; commentService.getUserComments(params),&#10;&#10;    staleTime: 1000 * 60 * 5, // 5분간 데이터를 신선하다고 간주&#10;    gcTime: 1000 * 60 * 10, // 10분간 캐시 유지&#10;  });&#10;}&#10;&#10;/**&#10; * 사용자가 좋아요한 게시글 목록을 가져오는 훅&#10; * &#10; * 이 훅은 TanStack Query의 useQuery를 사용하여:&#10; * - 사용자의 좋아요 목록을 자동 캐싱&#10; * - 백그라운드에서 자동 갱신  &#10; * - 로딩/에러 상태 자동 관리&#10; * - 좋아요 추가/취소 시 자동 무효화 가능&#10; * &#10; * @returns {object} 쿼리 결과 객체 (data, isLoading, error 등)&#10; */&#10;export function useMyLikes(params?: Pageable) {&#10;  return useQuery({&#10;    queryKey: [&quot;my-likes&quot;, params], // 캐시 키: 사용자의 좋아요 목록&#10;    queryFn: () =&gt; postService.getUserLikes(params),&#10;&#10;    staleTime: 1000 * 60 * 5, // 5분간 데이터를 신선하다고 간주&#10;    gcTime: 1000 * 60 * 10, // 10분간 캐시 유지&#10;  });&#10;}&#10;&#10;/**&#10; * 마이페이지 모든 데이터를 한 번에 가져오는 복합 훅&#10; * &#10; * 이 훅은 여러 쿼리를 병렬로 실행하여:&#10; * - 게시글, 댓글, 좋아요 데이터를 동시에 로드&#10; * - 각각의 로딩/에러 상태를 개별 관리&#10; * - 전체 로딩 상태와 각 섹션 상태를 모두 제공&#10; * &#10; * @returns {object} 모든 마이페이지 데이터와 상태&#10; */&#10;export function useMyPageData() {&#10;  const postsQuery = useMyPosts();&#10;  const commentsQuery = useMyComments();&#10;  const likesQuery = useMyLikes();&#10;&#10;  return {&#10;    // 각 섹션 데이터&#10;    posts: postsQuery.data || [],&#10;    comments: commentsQuery.data || [],&#10;    likes: likesQuery.data || [],&#10;&#10;    // 개별 로딩 상태&#10;    isLoadingPosts: postsQuery.isLoading,&#10;    isLoadingComments: commentsQuery.isLoading,&#10;    isLoadingLikes: likesQuery.isLoading,&#10;&#10;    // 전체 로딩 상태 (모든 쿼리가 로딩 중인지)&#10;    isLoading: postsQuery.isLoading || commentsQuery.isLoading || likesQuery.isLoading,&#10;&#10;    // 개별 에러 상태&#10;    postsError: postsQuery.error,&#10;    commentsError: commentsQuery.error,&#10;    likesError: likesQuery.error,&#10;&#10;    // 전체 에러 상태 (하나라도 에러가 있는지)&#10;    hasError: !!postsQuery.error || !!commentsQuery.error || !!likesQuery.error,&#10;&#10;    // 개별 쿼리 객체 (필요 시 직접 접근 가능)&#10;    postsQuery,&#10;    commentsQuery,&#10;    likesQuery,&#10;  };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/commentService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/commentService.ts" />
              <option name="originalContent" value="import { API_CONFIG } from &quot;../config/api&quot;;&#10;import { API_PATHS } from &quot;../constants/apiPaths&quot;;&#10;import { fetchWithAuth } from &quot;../lib/api&quot;;&#10;import { ApiResponse, PageableContent, PaginationParams } from &quot;../types/api&quot;;&#10;import { CommentData, MyCommentData } from &quot;../types/comment&quot;;&#10;&#10;&#10;// --- 커스텀 에러 클래스 ---&#10;export class CommentServiceError extends Error {&#10;  constructor(public status: number, message: string, public endpoint?: string) {&#10;    super(message);&#10;    this.name = 'CommentServiceError';&#10;  }&#10;}&#10;&#10;export const commentService = {&#10;&#10;  async registerComment(postId: number, content: object): Promise&lt;CommentData&gt; {&#10;    const endpoint = API_PATHS.comments.byPostId(postId);&#10;    const response = await fetchWithAuth(API_CONFIG.BASE_URL + endpoint, {&#10;      method: 'POST',&#10;      headers: {&#10;        'Content-Type': 'application/json',&#10;      },&#10;      body: JSON.stringify(content),&#10;    }) as Response;&#10;&#10;    if (!response.ok) {&#10;      throw new Error('Failed to register comment');&#10;    }&#10;&#10;    const apiResponse: ApiResponse&lt;CommentData&gt; = await response.json();&#10;&#10;    console.log(&quot;apiResponse.data&quot;, apiResponse.data);&#10;&#10;    return apiResponse.data;&#10;  },&#10;&#10;  // // editComment, 댓글 수정 api 작성&#10;  // async editComment(postId: number, content: object): Promise&lt;CommentData&gt; {&#10;  //   const endpoint = `/api/v1/comment/${postId}/comments`;&#10;  //   const response = await fetchWithAuth(API_CONFIG.BASE_URL + endpoint, {&#10;  //     method: 'POST',&#10;  //     headers: {&#10;  //       'Content-Type': 'application/json',&#10;  //     },&#10;  //     body: JSON.stringify(content),&#10;  //   }) as Response;&#10;&#10;  //   if (!response.ok) {&#10;  //     throw new Error('Failed to register comment');&#10;  //   }&#10;&#10;  //   const apiResponse: ApiResponse&lt;CommentData&gt; = await response.json();&#10;&#10;  //   console.log(&quot;apiResponse.data&quot;, apiResponse.data);&#10;&#10;  //   return apiResponse.data;&#10;  // },&#10;&#10;  async deleteComment(commentId: number): Promise&lt;void&gt; {&#10;    const endpoint = API_PATHS.comments.byId(commentId);&#10;    const response = await fetchWithAuth(API_CONFIG.BASE_URL + endpoint, {&#10;      method: 'DELETE',&#10;    }) as Response;&#10;&#10;    if (!response.ok) {&#10;      const errorData = await response.json().catch(() =&gt; ({ message: `Failed to delete comment ${commentId}` }));&#10;      throw new CommentServiceError(response.status, errorData.message || `Failed to delete comment ${commentId}`, endpoint);&#10;    }&#10;  },&#10;&#10;  async getUserComments(params?: PaginationParams): Promise&lt;PageableContent&lt;MyCommentData&gt;&gt; {&#10;    const endpoint = API_PATHS.comments.me;&#10;    const url = new URL(API_CONFIG.BASE_URL + endpoint);&#10;&#10;    if (params?.page !== undefined) url.searchParams.append('page', String(params.page));&#10;    if (params?.size !== undefined) url.searchParams.append('size', String(params.size));&#10;    if (params?.sort) params.sort.forEach((sort: string) =&gt; url.searchParams.append('sort', sort));&#10;&#10;    try {&#10;      const response = await fetchWithAuth(url.toString(), {&#10;        method: 'GET',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;      }) as Response;&#10;&#10;      if (!response.ok) {&#10;        const errorData = await response.json().catch(() =&gt; ({ message: 'Failed to fetch user comments' }));&#10;        throw new CommentServiceError(response.status, errorData.message || 'Failed to fetch user comments', endpoint);&#10;      }&#10;&#10;      const apiResponse: ApiResponse&lt;PageableContent&lt;MyCommentData&gt;&gt; = await response.json();&#10;      return apiResponse.data;&#10;    } catch (error) {&#10;      if (error instanceof CommentServiceError) {&#10;        throw error;&#10;      }&#10;      throw new CommentServiceError(500, (error as Error).message || 'An unexpected error occurred while fetching user comments', endpoint);&#10;    }&#10;  },&#10;&#10;&#10;};" />
              <option name="updatedContent" value="import { API_CONFIG } from &quot;@/config/api&quot;;&#10;import { API_PATHS } from &quot;@/constants/apiPaths&quot;;&#10;import { fetchWithAuth } from &quot;@/lib/api&quot;;&#10;import { ResponseDto, PagedResponse, Pageable, CommentResponse } from &quot;@/generated/api&quot;;&#10;&#10;&#10;// --- 커스텀 에러 클래스 ---&#10;export class CommentServiceError extends Error {&#10;  constructor(public status: number, message: string, public endpoint?: string) {&#10;    super(message);&#10;    this.name = 'CommentServiceError';&#10;  }&#10;}&#10;&#10;export const commentService = {&#10;&#10;  async registerComment(postId: number, content: object): Promise&lt;CommentResponse&gt; {&#10;    const endpoint = API_PATHS.comments.byPostId(postId);&#10;    const response = await fetchWithAuth(API_CONFIG.BASE_URL + endpoint, {&#10;      method: 'POST',&#10;      headers: {&#10;        'Content-Type': 'application/json',&#10;      },&#10;      body: JSON.stringify(content),&#10;    }) as Response;&#10;&#10;    if (!response.ok) {&#10;      throw new Error('Failed to register comment');&#10;    }&#10;&#10;    const apiResponse: ResponseDto = await response.json();&#10;&#10;    console.log(&quot;apiResponse.data&quot;, apiResponse.data);&#10;&#10;    return apiResponse.data as CommentResponse;&#10;  },&#10;&#10;  // // editComment, 댓글 수정 api 작성&#10;  // async editComment(postId: number, content: object): Promise&lt;CommentData&gt; {&#10;  //   const endpoint = `/api/v1/comment/${postId}/comments`;&#10;  //   const response = await fetchWithAuth(API_CONFIG.BASE_URL + endpoint, {&#10;  //     method: 'POST',&#10;  //     headers: {&#10;  //       'Content-Type': 'application/json',&#10;  //     },&#10;  //     body: JSON.stringify(content),&#10;  //   }) as Response;&#10;&#10;  //   if (!response.ok) {&#10;  //     throw new Error('Failed to register comment');&#10;  //   }&#10;&#10;  //   const apiResponse: ApiResponse&lt;CommentData&gt; = await response.json();&#10;&#10;  //   console.log(&quot;apiResponse.data&quot;, apiResponse.data);&#10;&#10;  //   return apiResponse.data;&#10;  // },&#10;&#10;  async deleteComment(commentId: number): Promise&lt;void&gt; {&#10;    const endpoint = API_PATHS.comments.byId(commentId);&#10;    const response = await fetchWithAuth(API_CONFIG.BASE_URL + endpoint, {&#10;      method: 'DELETE',&#10;    }) as Response;&#10;&#10;    if (!response.ok) {&#10;      const errorData = await response.json().catch(() =&gt; ({ message: `Failed to delete comment ${commentId}` }));&#10;      throw new CommentServiceError(response.status, errorData.message || `Failed to delete comment ${commentId}`, endpoint);&#10;    }&#10;  },&#10;&#10;  async getUserComments(params?: Pageable): Promise&lt;PagedResponse&gt; {&#10;    const endpoint = API_PATHS.comments.me;&#10;    const url = new URL(API_CONFIG.BASE_URL + endpoint);&#10;&#10;    if (params?.page !== undefined) url.searchParams.append('page', String(params.page));&#10;    if (params?.size !== undefined) url.searchParams.append('size', String(params.size));&#10;    if (params?.sort) params.sort.forEach((sort: string) =&gt; url.searchParams.append('sort', sort));&#10;&#10;    try {&#10;      const response = await fetchWithAuth(url.toString(), {&#10;        method: 'GET',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;      }) as Response;&#10;&#10;      if (!response.ok) {&#10;        const errorData = await response.json().catch(() =&gt; ({ message: 'Failed to fetch user comments' }));&#10;        throw new CommentServiceError(response.status, errorData.message || 'Failed to fetch user comments', endpoint);&#10;      }&#10;&#10;      const apiResponse: ResponseDto = await response.json();&#10;      return apiResponse.data as PagedResponse;&#10;    } catch (error) {&#10;      if (error instanceof CommentServiceError) {&#10;        throw error;&#10;      }&#10;      throw new CommentServiceError(500, (error as Error).message || 'An unexpected error occurred while fetching user comments', endpoint);&#10;    }&#10;  },&#10;&#10;&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/imageService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/imageService.ts" />
              <option name="originalContent" value="import { API_CONFIG } from &quot;@/config/api&quot;;&#10;import { API_PATHS } from &quot;@/constants/apiPaths&quot;;&#10;import { fetchWithAuth } from &quot;@/lib/api&quot;;&#10;import { ApiResponse } from &quot;@/types/api&quot;;&#10;&#10;export class ImageServiceError extends Error {&#10;  constructor(public status: number, message: string, public endpoint?: string) {&#10;    super(message);&#10;    this.name = 'ImageServiceError';&#10;  }&#10;}&#10;&#10;export const imageService = {&#10;  /**&#10;   * 이미지를 업로드하고 URL을 반환합니다.&#10;   * @param file - 업로드할 이미지 파일&#10;   * @returns 업로드된 이미지 URL&#10;   */&#10;  async uploadImage(file: File): Promise&lt;string&gt; {&#10;    const endpoint = API_PATHS.posts.images;&#10;&#10;    try {&#10;      const formData = new FormData();&#10;      formData.append('file', file);&#10;&#10;      const response = await fetchWithAuth(API_CONFIG.BASE_URL + endpoint, {&#10;        method: 'POST',&#10;        body: formData,&#10;        // Content-Type은 FormData 사용 시 자동으로 설정되므로 설정하지 않음&#10;      }) as Response;&#10;&#10;      if (!response.ok) {&#10;        const errorData = await response.json().catch(() =&gt; ({&#10;          message: 'Failed to upload image'&#10;        }));&#10;        throw new ImageServiceError(&#10;          response.status,&#10;          errorData.message || 'Failed to upload image',&#10;          endpoint&#10;        );&#10;      }&#10;&#10;      const apiResponse: ApiResponse&lt;string&gt; = await response.json();&#10;      return apiResponse.data; // 업로드된 이미지 URL 반환&#10;    } catch (error) {&#10;      if (error instanceof ImageServiceError) {&#10;        throw error;&#10;      }&#10;      throw new ImageServiceError(&#10;        500,&#10;        (error as Error).message || 'An unexpected error occurred while uploading image',&#10;        endpoint&#10;      );&#10;    }&#10;  }&#10;} as const;&#10;" />
              <option name="updatedContent" value="import { API_CONFIG } from &quot;@/config/api&quot;;&#10;import { API_PATHS } from &quot;@/constants/apiPaths&quot;;&#10;import { fetchWithAuth } from &quot;@/lib/api&quot;;&#10;import { ResponseDto } from &quot;@/generated/api&quot;;&#10;&#10;export class ImageServiceError extends Error {&#10;  constructor(public status: number, message: string, public endpoint?: string) {&#10;    super(message);&#10;    this.name = 'ImageServiceError';&#10;  }&#10;}&#10;&#10;export const imageService = {&#10;  /**&#10;   * 이미지를 업로드하고 URL을 반환합니다.&#10;   * @param file - 업로드할 이미지 파일&#10;   * @returns 업로드된 이미지 URL&#10;   */&#10;  async uploadImage(file: File): Promise&lt;string&gt; {&#10;    const endpoint = API_PATHS.posts.images;&#10;&#10;    try {&#10;      const formData = new FormData();&#10;      formData.append('file', file);&#10;&#10;      const response = await fetchWithAuth(API_CONFIG.BASE_URL + endpoint, {&#10;        method: 'POST',&#10;        body: formData,&#10;        // Content-Type은 FormData 사용 시 자동으로 설정되므로 설정하지 않음&#10;      }) as Response;&#10;&#10;      if (!response.ok) {&#10;        const errorData = await response.json().catch(() =&gt; ({&#10;          message: 'Failed to upload image'&#10;        }));&#10;        throw new ImageServiceError(&#10;          response.status,&#10;          errorData.message || 'Failed to upload image',&#10;          endpoint&#10;        );&#10;      }&#10;&#10;      const apiResponse: ResponseDto = await response.json();&#10;      return apiResponse.data as string; // 타입 단언을 사용하여 string으로 캐스팅&#10;    } catch (error) {&#10;      if (error instanceof ImageServiceError) {&#10;        throw error;&#10;      }&#10;      throw new ImageServiceError(&#10;        500,&#10;        (error as Error).message || 'An unexpected error occurred while uploading image',&#10;        endpoint&#10;      );&#10;    }&#10;  }&#10;} as const;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>